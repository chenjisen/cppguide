# Google C++ 风格指南

# 背景

C++ 是 Google 许多开源项目使用的主要开发语言之一。每个 C++ 程序员都知道，该语言具有许多强大的功能，但这种功能也带来了复杂性，这反过来又会使代码更容易出现错误，并且更难以阅读和维护。

本指南的目标是通过详细描述编写 C++ 代码的注意事项来管理这种复杂性。这些规则的存在是为了保持代码库的可管理性，同时仍然允许编码人员高效地使用 C++ 语言功能。

_Style_，也称为可读性，是我们所说的管理 C++ 代码的约定。术语 `样式` 有点用词不当，因为这些约定涵盖的不仅仅是源文件格式。

Google 开发的大多数开源项目都符合本指南中的要求。

请注意，本指南不是 C++ 教程：我们假设读者熟悉该语言。

## 风格指南的目标

为什么我们有这个文件？

我们认为本指南应该服务于几个核心目标。这些是构成所有单独规则基础的根本原因。通过将这些想法带到前台，我们希望能够开展讨论，并使我们更广泛的社区更清楚地了解制定这些规则的原因以及做出特定决定的原因。如果您了解每条规则的服务目标，那么每个人都应该更清楚何时可以放弃某条规则（有些可以放弃），以及需要什么样的论点或替代方案来更改指南中的规则。

我们目前看到的风格指南的目标如下：

- 风格规则应该发挥作用

样式规则的好处必须足够大，才能要求我们所有的工程师记住它。好处是相对于我们在没有规则的情况下获得的代码库来衡量的，因此，如果人们无论如何都不太可能这样做，那么针对非常有害的做法的规则可能仍然会带来很小的好处。这个原则主要解释了我们没有的规则，而不是我们有的规则：例如， `goto` 违反了以下许多原则，但已经很少见，因此样式指南没有讨论它。

- 针对读者而不是作者进行优化

我们的代码库（以及提交给它的大多数单独组件）预计将持续相当长的一段时间。因此，阅读大部分代码所花费的时间比编写代码的时间还要多。我们明确选择针对普通软件工程师在代码库中阅读、维护和调试代码的体验进行优化，而不是在编写所述代码时变得轻松。  `为读者留下痕迹` 是该原则的一个特别常见的子点：当一段代码中发生令人惊讶或不寻常的事情时（例如，指针所有权的转移），在该点为读者留下文本提示使用是有价值的（`std::unique_ptr`在调用站点明确地演示了所有权转移）。

- 与现有代码保持一致

在我们的代码库中一致使用一种风格可以让我们专注于其他（更重要的）问题。一致性还可以实现自动化：只有当您的代码与工具的期望一致时，格式化代码或调整 `#include` 的工具才能正常工作。在许多情况下，归因于 `保持一致` 的规则归结为 `只选择一个，不再担心它` ；在这些问题上允许灵活性的潜在价值被人们争论的成本所抵消。然而，一致性是有限制的；当没有明确的技术论证或长期方向时，这是一个很好的平局打破者。它在本地应用更广泛（每个文件，或一组紧密相关的接口）。一般来说，一致性不应该被用作以旧风格做事的理由，而不考虑新风格的好处，或者代码库随着时间的推移向新风格收敛的趋势。

- 适当时与更广泛的 C++ 社区保持一致

与其他组织使用 C++ 的方式保持一致具有价值，其原因与我们代码库中的一致性相同。如果 C++ 标准中的某个功能解决了某个问题，或者某个惯用语被广泛知晓并接受，那就是使用它的理由。然而，有时标准功能和习惯用法是有缺陷的，或者只是在设计时没有考虑到我们的代码库的需求。在这些情况下（如下所述），限制或禁止标准功能是适当的。在某些情况下，我们更喜欢自行开发的或第三方的库，而不是 C++ 标准中定义的库，要么是出于感知的优越性，要么是没有足够的价值将代码库转换为标准接口。

- 避免令人惊讶或危险的构造

C++ 的特性比人们乍一看更令人惊讶或更危险。一些样式指南限制是为了防止陷入这些陷阱。样式指南对此类限制的豁免有很高的门槛，因为放弃此类规则通常会直接面临损害程序正确性的风险。

- 避免我们的普通 C++ 程序员会觉得棘手或难以维护的结构

C++ 具有可能不适合普遍使用的功能，因为它们给代码带来了复杂性。在广泛使用的代码中，使用更复杂的语言结构可能更容易被接受，因为更复杂的实现的任何好处都会随着使用而大幅增加，并且在使用代码的新部分时不需要再次付出理解复杂性的成本。代码库。如有疑问，可以通过询问您的项目负责人来寻求此类规则的豁免。这对于我们的代码库尤其重要，因为代码所有权和团队成员资格会随着时间的推移而发生变化：即使使用某些代码的每个人目前都理解它，这种理解也不能保证在几年后仍然有效。

- 注意我们的规模

由于代码库包含 1 亿多行代码和数千名工程师，一名工程师的一些错误和简化可能会让许多工程师付出高昂的代价。例如，避免污染全局命名空间尤为重要：如果每个人都将内容放入全局命名空间，则数亿行代码库中的名称冲突将很难处理且难以避免。

- 必要时允许优化

性能优化有时可能是必要且适当的，即使它们与本文档的其他原则相冲突。

本文件的目的是提供最大程度的指导和合理的限制。一如既往，常识和良好品味应该占上风。我们特指整个 Google C++ 社区的既定惯例，而不仅仅是您的个人偏好或您团队的偏好。对巧妙或不寻常的结构持怀疑态度并不愿使用：没有禁令并不等于获得继续进行的许可。运用您的判断，如果您不确定，请随时询问您的项目负责人以获取更多信息。

# C++ 版本

目前，代码应以 C++17 为目标，即不应使用 C++2x 功能，_指定的初始化程序_ 除外。本指南针对的 C++ 版本将随着时间的推移（积极地）进步。

不要使用[非标准扩展](#Nonstandard_Extensions)。

在项目中使用 C++14 和 C++17 的功能之前，请考虑向其他环境的可移植性。

# 头文件

一般来说，每个 `.cc` 文件都应该有一个关联的 `.h` 文件。有一些常见的例外，例如单元测试和仅包含 `main()` 函数的小 `.cc` 文件。

正确使用头文件可以对代码的可读性、大小和性能产生巨大的影响。

以下规则将指导您克服使用头文件的各种陷阱。

## 自包含标头

头文件应该是独立的（自行编译）并以 `.h` 结尾。旨在包含的非头文件应以 `.inc` 结尾，并谨慎使用。

所有头文件都应该是独立的。用户和重构工具不必遵守特殊条件才能包含标头。具体来说，标头应该具有_标头防护_并包含它需要的所有其他标头。

当标头声明标头的客户端将实例化的内联函数或模板时，内联函数和模板也必须在标头中直接或在其包含的文件中具有定义。不要将这些定义移动到单独包含的头文件（`-inl.h`）中；这种做法过去很常见，但现在已不再允许。当模板的所有实例化都出现在一个 `.cc` 文件中时，要么因为它们是[显式](https://en.cppreference.com/w/cpp/language/class_template#Explicit_instantiation)，要么因为定义是可访问的仅 `.cc` 文件，模板定义可以保留在该文件中。

在极少数情况下，设计为包含的文件不是独立的。这些通常旨在包含在不寻常的位置，例如另一个文件的中间。他们可能不使用_标头防护_，并且可能不包含其先决条件。使用 `.inc` 扩展名命名此类文件。谨慎使用，并尽可能选择独立的标头。

## #define 守卫

所有头文件都应该有 `#define` 保护以防止多重包含。符号名称的格式应为 `_<PROJECT>___<PATH>___<FILE>__H_` 。

为了保证唯一性，它们应该基于项目源树中的完整路径。例如，项目 `foo` 中的文件 `foo/src/bar/baz.h` 应该具有以下保护：

```C++
#ifndef FOO_BAR_BAZ_H_
#定义FOO_BAR_BAZ_H_

...

#endif // FOO_BAR_BAZ_H_
```

## 包括您使用的内容

如果源文件或头文件引用在其他地方定义的符号，则该文件应直接包含一个头文件，该头文件正确地旨在提供该符号的声明或定义。出于任何其他原因，它不应包含头文件。

不要依赖传递包含。这允许人们从标头中删除不再需要的 `#include` 语句，而不会破坏客户端。这也适用于相关标头 - 如果 `foo.cc` 使用其中的符号，则 `foo.cc` 应该包含 `bar.h` ，即使 `foo.h` 包含 `bar.h` 。

## 转发声明

尽可能避免使用前向声明。相反，_包含您需要的标头_。

 `前向声明` 是没有关联定义的实体的声明。

```C++
// 在 C++ 源文件中：
B 级；
无效 FuncInB();
外部 int 变量_in_b；
ABSL_DECLARE_FLAG(flag_in_b);
```

- 前向声明可以节省编译时间，因为 `#include` 强制编译器打开更多文件并处理更多输入。
- 前向声明可以节省不必要的重新编译。由于标头中不相关的更改， `#include` 可能会强制您的代码更频繁地重新编译。

- 前向声明可以隐藏依赖项，允许用户代码在标头更改时跳过必要的重新编译。
- 与 `#include` 语句相反的前向声明使得自动工具很难发现定义符号的模块。
- 前向声明可能会因库的后续更改而被破坏。函数和模板的前向声明可以防止标头所有者对其 API 进行其他兼容的更改，例如扩大参数类型、添加具有默认值的模板参数或迁移到新的命名空间。
- 从名称空间 `std::` 向前声明符号会产生未定义的行为。
- 可能很难确定是否需要前向声明或完整的 `#include` 。用前向声明替换`#include`可以默默地改变代码的含义：

```C++
// bh:
结构体B{}；
结构体D：B{}；

// 好用户.cc:
#包括 `bh`
无效 f(B*);
无效 f(无效*);
无效测试(D* x) { f(x); } // 调用 f(B*)
```

如果将 `#include` 替换为 `B` 和 `D` 的前向声明，则 `test()` 将调用 `f(void*)` 。

- 从标头中转发声明多个符号可能比简单地 `#include` 标头更详细。
- 构建代码以启用前向声明（例如，使用指针成员而不是对象成员）可能会使代码更慢且更复杂。

尽量避免在另一个项目中定义的实体的前向声明。

## 内联函数

仅当函数很小时（例如 10 行或更少）时才定义内联函数。

您可以以允许编译器内联扩展函数的方式声明函数，而不是通过通常的函数调用机制调用它们。

只要内联函数很小，内联函数就可以生成更有效的目标代码。随意内联访问器和修改器以及其他简短的、性能关键的函数。

过度使用内联实际上会使程序变慢。根据函数的大小，内联它可能会导致代码大小增加或减少。内联一个非常小的访问器函数通常会减少代码大小，而内联一个非常大的函数会显着增加代码大小。在现代处理器上，由于更好地利用指令缓存，较小的代码通常运行得更快。

一个不错的经验法则是，如果函数长度超过 10 行，则不要内联函数。小心析构函数，由于隐式的成员析构函数和基析构函数调用，析构函数通常比它们看起来要长！

另一个有用的经验法则：使用循环或 switch 语句内联函数通常不具有成本效益（除非在常见情况下，循环或 switch 语句从不执行）。

重要的是要知道函数并不总是内联的，即使它们是这样声明的；例如，虚拟函数和递归函数通常不是内联的。通常递归函数不应该是内联的。使虚拟函数内联的主要原因是将其定义放在类中，要么是为了方便，要么是为了记录其行为，例如访问器和修改器。

## 包含的名称和顺序

按以下顺序包含头文件：相关头文件、C 系统头文件、C++ 标准库头文件、其他库的头文件、您项目的头文件。

项目的所有头文件都应列为项目源目录的后代，而不使用 UNIX 目录别名 `.` （当前目录）或 `..` （父目录）。例如， `google-awesome-project/src/base/logging.h` 应包含为：

```C++
#include `base/logging.h`
```

在 `dir/foo.cc` 或 `dir/foo_test.cc` 中，其主要目的是实现或测试 `dir2/foo2.h` 中的内容，按如下方式排序您的包含内容：

1.`dir2/foo2.h`。
2. 空行
3. C 系统头文件（更准确地说：尖括号中带有 `.h` 扩展名的头文件），例如 `<unistd.h>` 、 `<stdlib.h>` 。
4. 空行
5. C++ 标准库头文件（不带文件扩展名），例如`<algorithm>`、`<cstddef>`。
6. 空行

- 其他库的`.h`文件。
- 一个空行

8. 您项目的 `.h` 文件。

用一个空行分隔每个非空组。

使用首选顺序，如果相关标头 `dir2/foo2.h` 省略任何必要的包含， `dir/foo.cc` 或 `dir/foo_test.cc` 的构建将中断。因此，此规则确保构建中断首先出现在处理这些文件的人员身上，而不是其他软件包中的无辜人员身上。

`dir/foo.cc` 和 `dir2/foo2.h` 通常位于同一目录中（例如，`base/basictypes_test.cc` 和 `base/basictypes.h`），但有时也可能位于不同目录中。

请注意，C 头文件（例如 `stddef.h` ）本质上可以与 C++ 头文件（ `cstddef` ）互换。任何一种风格都可以接受，但更喜欢与现有代码保持一致。

每个部分中的包含内容应按字母顺序排列。请注意，较旧的代码可能不符合此规则，应在方便时进行修复。

例如， `google-awesome-project/src/foo/internal/fooserver.cc` 中的包含内容可能如下所示：

```C++
#include `foo/server/fooserver.h`

#include <sys/types.h>
#include <unistd.h>

#include <字符串>
#include <向量>

#include `基本/基本类型.h`
#include `foo/server/bar.h`
#include `third_party/absl/flags/flag.h`
```

**例外：**

有时，系统特定的代码需要条件包含。此类代码可以将条件包含放在其他包含之后。当然，请保持系统特定的代码较小且本地化。例子：

```C++
#include `foo/public/fooserver.h`

#include "base/port.h" // 对于 LANG_CXX11。

#ifdef LANG_CXX11
#include <初始化列表>
#endif // LANG_CXX11
```

# 范围界定

## 命名空间

除少数例外，将代码放置在命名空间中。命名空间应该具有基于项目名称及其路径的唯一名称。不要使用_using-directives_（例如，`using namespace foo`）。不要使用内联命名空间。对于未命名的命名空间，请参阅_内部链接_。

命名空间将全局范围细分为不同的命名范围，因此对于防止全局范围中的名称冲突非常有用。

命名空间提供了一种防止大型程序中名称冲突的方法，同时允许大多数代码使用相当短的名称。

例如，如果两个不同的项目在全局范围内有一个类 `Foo` ，这些符号可能会在编译时或运行时发生冲突。如果每个项目将其代码放在命名空间中，则 `project1::Foo` 和 `project2::Foo` 现在是不冲突的不同符号，并且每个项目命名空间内的代码可以继续引用 `Foo` 而不带前缀。

内联命名空间会自动将其名称放置在封闭范围内。例如，考虑以下代码片段：

**中性代码**

```C++
命名空间外部{
内联命名空间内部{
无效 foo();
} // 命名空间内部
} // 外部命名空间
```

表达式 `outer::inner::foo()` 和 `outer::foo()` 是可以互换的。内联命名空间主要用于跨版本的 ABI 兼容性。

命名空间可能会令人困惑，因为它们使确定名称所指定义的机制变得复杂。

特别是内联命名空间可能会令人困惑，因为名称实际上并不限于声明它们的命名空间。它们仅作为某些较大版本控制策略的一部分有用。

在某些情况下，有必要通过符号的完全限定名称重复引用它们。对于深度嵌套的命名空间，这可能会增加很多混乱。

命名空间应按如下方式使用：

- 遵循_命名空间名称_的规则。
- 使用注释终止多行名称空间，如给定示例所示。
- 命名空间在包含、[gflags](https://gflags.github.io/gflags/)定义/声明以及来自其他命名空间的类的前向声明之后包装整个源文件。

```C++
// 在.h文件中
命名空间 mynamespace {

// 所有声明都在命名空间范围内。
// 注意缺少缩进。
类我的类{
民众：
...
无效 Foo();
};

} // 命名空间 mynamespace
```

```C++
// 在.cc 文件中
命名空间 mynamespace {

// 函数的定义在命名空间的范围内。
无效MyClass::Foo() {
...
}

} // 命名空间 mynamespace
```

更复杂的 `.cc` 文件可能包含其他详细信息，例如标志或使用声明。

```C++
#包括 `啊`

ABSL_FLAG(bool, someflag, false, "一个标志");

命名空间 mynamespace {

使用 ::foo::Bar;

...mynamespace 的代码... // 代码与左边距相反。

} // 命名空间 mynamespace
```

- 要将生成的协议消息代码放置在命名空间中，请在 `.proto` 文件中使用 `package` 说明符。有关详细信息，请参阅[协议缓冲区包](https://developers.google.com/protocol-buffers/docs/reference/cpp- generated#package)。
- 不要在命名空间 `std` 中声明任何内容，包括标准库类的前向声明。在名称空间 `std` 中声明实体是未定义的行为，即不可移植。要声明标准库中的实体，请包含适当的头文件。
- 您不能使用 _using-directive_ 来使命名空间中的所有名称可用。

**错误代码**

```C++
// 禁止——这会污染命名空间。
使用命名空间 foo；
```

- 不要在头文件中的命名空间范围内使用_命名空间别名_，除非在显式标记的仅限内部命名空间中，因为导入到头文件中的命名空间中的任何内容都会成为该文件导出的公共 API 的一部分。

```C++
// 缩短对 .cc 文件中一些常用名称的访问。
命名空间 baz = ::foo::bar::baz;
```

```C++
// 缩短对一些常用名称的访问（在 .h 文件中）。
命名空间图书馆员{
namespace impl { // 内部的，不是 API 的一部分。
命名空间 sidetable = ::pipeline_diagnostics::sidetable;
} // 命名空间实现

内联无效 my_inline_function() {
// 函数（或方法）本地的命名空间别名。
命名空间 baz = ::foo::bar::baz;
...
}
} // 命名空间库管理员
```

- 不要使用内联命名空间。
- 使用名称中带有 `internal` 的命名空间来记录 API 用户不应提及的 API 部分。

**错误代码**

```C++
// 我们不应该在非absl 代码中使用这个内部名称。
使用::absl::container_internal::ImplementationDetail；
```

## 内部链接

当 `.cc` 文件中的定义不需要在该文件外部引用时，可以通过将它们放置在未命名的命名空间中或将它们声明为 `static` 来提供内部链接。不要在 `.h` 文件中使用这些结构。

所有声明都可以通过将它们放置在未命名的命名空间中来给予内部链接。函数和变量也可以通过声明为 `static` 来给予内部链接。这意味着您声明的任何内容都无法从另一个文件访问。如果不同的文件声明具有相同名称的内容，则这两个实体是完全独立的。

对于不需要在其他地方引用的所有代码，鼓励使用 `.cc` 文件中的内部链接。不要在 `.h` 文件中使用内部链接。

像命名命名空间一样设置未命名命名空间的格式。在终止注释中，将命名空间名称留空：

```C++
命名空间{
...
} // 命名空间
```

## 非成员、静态成员和全局函数

更喜欢将非成员函数放在命名空间中；很少使用完全全局的函数。不要仅仅使用类来对静态成员进行分组。类的静态方法通常应该与类的实例或类的静态数据密切相关。

非成员函数和静态成员函数在某些情况下可能很有用。将非成员函数放入命名空间可以避免污染全局命名空间。

非成员和静态成员函数作为新类的成员可能更有意义，特别是当它们访问外部资源或具有显着依赖性时。

有时定义一个不绑定到类实例的函数很有用。这样的函数可以是静态成员函数或非成员函数。非成员函数不应依赖于外部变量，并且几乎应始终存在于命名空间中。不要创建类只是为了对静态成员进行分组；这与仅仅给名称提供一个共同的前缀没有什么不同，而且这样的分组通常是不必要的。

如果您定义了一个非成员函数并且仅在其 `.cc` 文件中需要它，请使用_内部链接_来限制其范围。

## 局部变量

将函数的变量放置在尽可能窄的范围内，并在声明中初始化变量。

C++ 允许您在函数中的任何位置声明变量。我们鼓励您在尽可能本地的范围内声明它们，并尽可能接近第一次使用。这使得读者更容易找到声明并查看变量的类型以及它被初始化为什么。特别是，应该使用初始化而不是声明和赋值，例如：

**错误代码**

```C++
整数我；
我 = f(); // 不好——初始化与声明分开。
```

```C++
int i = f(); // 好——声明有初始化。
```

**错误代码**

```C++
int 职位 = NumJobs();
// 更多代码...
f（工作）； // 不好——声明与使用分开。
```

```C++
int 职位 = NumJobs();
f（工作）； // 好——声明后立即（或紧接着）使用。
```

**错误代码**

```C++
std::vector<int> v;
v.push_back(1); // 优先使用大括号初始化进行初始化。
v.push_back(2);
```

```C++
std::vector<int> v = {1, 2}; // 好——v 开始初始化。
```

 `if` 、 `while` 和 `for` 语句所需的变量通常应在这些语句内声明，以便这些变量被限制在这些范围内。例如：

```C++
while (const char* p = strchr(str, '/')) str = p + 1;
```

有一个警告：如果变量是一个对象，则每次进入作用域并创建时都会调用其构造函数，每次超出作用域时都会调用其析构函数。

**错误代码**

```C++
// 低效的实现：
for (int i = 0; i < 1000000; ++i) {
富夫； // 我的 ctor 和 dtor 分别被调用 1000000 次。
f.DoSomething(i);
}
```

在循环外部声明一个在循环中使用的变量可能会更有效：

```C++
富夫； // 我的 ctor 和 dtor 各被调用一次。
for (int i = 0; i < 1000000; ++i) {
f.DoSomething(i);
}
```

## 静态和全局变量

禁止具有[静态存储持续时间](http://en.cppreference.com/w/cpp/language/storage_duration#Storage_duration)的对象，除非它们[可轻易破坏](http://en.cppreference.com/w/ cpp/types/is_destructible）。非正式地，这意味着析构函数不执行任何操作，即使考虑到成员和基析构函数。更正式地说，它意味着该类型没有用户定义的或虚拟的析构函数，并且所有基类和非静态成员都是可轻易破坏的。静态函数局部变量可以使用动态初始化。不鼓励对静态类成员变量或命名空间范围内的变量使用动态初始化，但在有限的情况下允许；详情请参见下文。

根据经验，如果全局变量的声明（单独考虑）可以是 `constexpr` ，则它满足这些要求。

每个对象都有一个存储持续时间，这与其生命周期相关。具有静态存储持续时间的对象从其初始化点一直存活到程序结束。此类对象显示为名称空间范围内的变量（ `全局变量` ）、类的静态数据成员或使用 `static` 说明符声明的函数局部变量。函数局部静态变量在控制权首次通过其声明时被初始化；所有其他具有静态存储持续时间的对象都作为程序启动的一部分进行初始化。所有具有静态存储持续时间的对象都会在程序退出时被销毁（这发生在未加入的线程终止之前）。

初始化可能是动态的，这意味着初始化期间会发生一些重要的事情。 （例如，考虑分配内存的构造函数，或使用当前进程 ID 初始化的变量。）另一种初始化是静态初始化。不过，这两者并不完全相反：静态初始化_always_发生在具有静态存储持续时间的对象上（将对象初始化为给定常量或由所有字节设置为零的表示形式），而动态初始化发生在这之后，如果必需的。

全局变量和静态变量对于大量应用程序非常有用：命名常量、某些翻译单元内部的辅助数据结构、命令行标志、日志记录、注册机制、后台基础设施等。

使用动态初始化或具有重要析构函数的全局变量和静态变量会产生复杂性，很容易导致难以发现的错误。动态初始化不是跨翻译单元排序的，销毁也不是（除了销毁以与初始化相反的顺序发生）。当一个初始化引用另一个具有静态存储持续时间的变量时，这可能会导致对象在其生命周期开始之前（或在其生命周期结束之后）被访问。此外，当程序启动在退出时未加入的线程时，如果这些线程的析构函数已经运行，则这些线程可能会在其生命周期结束后尝试访问对象。

### 销毁决定

当析构函数很简单时，它们的执行根本不受顺序限制（它们实际上不是 `运行` ）；否则，我们将面临在对象生命周期结束后访问对象的风险。因此，我们只允许具有静态存储持续时间的对象（如果它们是可轻易破坏的）。基本类型（如指针和 `int` ）是普通可破坏的，普通可破坏类型的数组也是如此。请注意，标有 `constexpr` 的变量是可破坏的。

```C++
常量整数 kNum = 10; // 允许

结构 X { int n; };
const X kX[] = {{1}, {2}, {3}}; // 允许

无效 foo() {
static const char* const kMessages[] = {"hello", "world"}; // 允许
}

// 允许：constexpr 保证简单的析构函数。
constexpr std::array<int, 3> kArray = {1, 2, 3};
```

**错误代码**

```C++
// 不好：不平凡的析构函数
const std::string kFoo = "foo";

// 由于同样的原因不好，即使 kBar 是一个引用（
// 规则也适用于延长生命周期的临时对象）。
const std::string& kBar = StrCat("a", "b", "c");

无效栏（）{
// 不好：不平凡的析构函数。
静态 std::map<int, int> kData = {{1, 0}, {2, 0}, {3, 0}};
}
```

请注意，引用不是对象，因此它们不受可破坏性的约束。不过，动态初始化的限制仍然适用。特别是，允许使用 `static T& t = *new T;` 形式的函数局部静态引用。

### 初始化决定

初始化是一个更复杂的主题。这是因为我们不仅要考虑类构造函数是否执行，还必须考虑初始化器的评估：

**中性代码**

```C++
整数 n = 5； // 美好的
int m = f(); // ? （取决于 f）
富x; // ? （取决于 Foo::Foo）
条 y = g(); // ? （取决于 g 和 Bar::Bar）
```

除了第一条语句之外的所有语句都让我们面临不确定的初始化顺序。

我们正在寻找的概念在 C++ 标准的形式语言中称为 `常量初始化` 。这意味着初始化表达式是一个常量表达式，如果对象是通过构造函数调用初始化的，那么构造函数也必须指定为 `constexpr` ：

```C++
struct Foo { constexpr Foo(int) {} };

整数 n = 5； // 很好，5 是一个常量表达式。
富 x(2); // 很好，2 是一个常量表达式，选择的构造函数是 constexpr。
Foo a[] = { Foo(1), Foo(2), Foo(3) }; // 美好的
```

始终允许常量初始化。静态存储持续时间变量的常量初始化应使用 `constexpr` 进行标记，或者在可能的情况下使用 [`ABSL_CONST_INIT`](https://github.com/abseil/abseil-cpp/blob/03c1513538584f4a04d666be5eb469e3979febba/absl/base/attributes.h# L540）属性。任何没有如此标记的非本地静态存储持续时间变量都应该被假定为具有动态初始化，并非常仔细地检查。

相比之下，以下初始化是有问题的：

**错误代码**

```C++
// 下面使用了一些声明。
time_t 时间(time_t*); // 不是 constexpr！
int f(); // 不是 constexpr！
结构体 Bar { Bar() {} };

// 有问题的初始化。
time_t m = 时间(nullptr); // 初始化表达式不是常量表达式。
Foo y(f()); // 同上
酒吧b； // 选择构造函数 Bar::Bar() 而不是 constexpr。
```

不鼓励动态初始化非局部变量，并且一般来说是禁止的。但是，如果程序的任何方面都不依赖于此初始化相对于所有其他初始化的顺序，我们确实允许这样做。在这些限制下，初始化的顺序不会产生明显的差异。例如：

```C++
int p = getpid(); // 允许，只要没有其他静态变量
// 在其自身的初始化中使用 p。
```

静态局部变量的动态初始化是允许的（并且很常见）。

### 常见模式

- 全局字符串：如果需要命名全局或静态字符串常量，请考虑使用指向字符串文字的 `string_view` 、字符数组或字符指针的 `constexpr` 变量。字符串文字已经具有静态存储持续时间，并且通常就足够了。请参阅[TotW #140。](https://abseil.io/tips/140)
- 映射、集合和其他动态容器：如果您需要静态、固定的集合（例如要搜索的集合或查找表），则不能将标准库中的动态容器用作静态变量，因为它们不具有静态变量。 - 琐碎的析构函数。相反，考虑一个由简单类型组成的简单数组，例如，整数数组的数组（用于 `从 int 到 int 的映射` ），或对数组（例如， `int` 和 `const char*` 对） 。对于小型集合，线性搜索完全足够（并且由于内存局部性而有效）；考虑使用 [absl/algorithm/container.h](https://github.com/abseil/abseil-cpp/blob/master/absl/algorithm/container.h) 中的设施进行标准操作。如有必要，请保持集合按排序顺序并使用二分搜索算法。如果您确实更喜欢标准库中的动态容器，请考虑使用函数局部静态指针，如下所述。
- 智能指针（`std::unique_ptr`、`std::shared_ptr`）：智能指针在销毁期间执行清理，因此被禁止。考虑您的用例是否适合本节中描述的其他模式之一。一个简单的解决方案是使用指向动态分配对象的普通指针，并且永远不删除它（请参阅最后一项）。
- 自定义类型的静态变量：如果您需要需要自己定义的类型的静态常量数据，请为该类型提供一个简单的析构函数和一个 `constexpr` 构造函数。
- 如果所有其他方法都失败，您可以动态创建一个对象，并且永远不会使用函数本地静态指针或引用删除它（例如，`static const auto& impl = *new T(args...);`）。

## thread_local 变量

未在函数内声明的 thread_local 变量必须使用真正的编译时常量进行初始化，并且必须使用 [`ABSL_CONST_INIT`](https://github.com/abseil/abseil-cpp /blob/master/absl/base/attributes.h) 属性。与其他定义线程本地数据的方法相比，更喜欢使用 `thread_local` 。

可以使用 `thread_local` 说明符声明变量：

```C++
thread_local Foo foo = ...;
```

这样的变量实际上是一个对象的集合，这样不同的线程访问它时，实际上访问的是不同的对象。 `thread_local` 变量在很多方面都很像_静态存储持续时间变量_。例如，它们可以在命名空间范围、函数内部或作为静态类成员声明，但不能作为普通类成员声明。

 `thread_local` 变量实例的初始化与静态变量非常相似，只不过它们必须为每个线程单独初始化，而不是在程序启动时初始化一次。这意味着函数中声明的 `thread_local` 变量是安全的，但其他 `thread_local` 变量会受到与静态变量相同的初始化顺序问题（以及更多问题）的影响。

`thread_local` 变量有一个微妙的销毁顺序问题：在线程关闭期间，`thread_local` 变量将以与初始化相反的顺序销毁（C++ 中通常如此）。如果由任何 `thread_local` 变量的析构函数触发的代码引用该线程上任何已销毁的 `thread_local` ，我们将特别难以诊断释放后使用。

- 线程本地数据本质上是安全的，不会出现竞争（因为通常只有一个线程可以访问它），这使得 `thread_local` 对于并发编程非常有用。
- `thread_local` 是创建线程本地数据的唯一标准支持的方式。

- 访问 `thread_local` 变量可能会在线程启动或首次在给定线程上使用期间触发不可预测且无法控制数量的其他代码的执行。
- `thread_local` 变量实际上是全局变量，除了缺乏线程安全性之外，具有全局变量的所有缺点。
-  `thread_local` 变量消耗的内存随着正在运行的线程数量（在最坏的情况下）而变化，这在程序中可能非常大。
- 数据成员不能是 `thread_local` ，除非它们也是 `static` 。
- 如果 `thread_local` 变量具有复杂的析构函数，我们可能会遇到释放后使用错误。特别是，任何此类变量的析构函数不得（传递地）调用任何引用任何可能被破坏的 `thread_local` 的代码。该属性很难执行。
- 避免全局/静态上下文中释放后使用的方法不适用于 `thread_local` 。具体来说，跳过全局变量和静态变量的析构函数是允许的，因为它们的生命周期在程序关闭时结束。因此，任何 `泄漏` 都会立即由操作系统清理内存和其他资源来管理。相比之下，跳过 `thread_local` 变量的析构函数会导致资源泄漏，该泄漏与程序生命周期内终止的线程总数成正比。

类或命名空间范围内的 `thread_local` 变量必须使用真正的编译时常量进行初始化（即，它们必须没有动态初始化）。为了强制执行此操作，类或命名空间范围内的 `thread_local` 变量必须使用 [`ABSL_CONST_INIT`](https://github.com/abseil/abseil-cpp/blob/master/absl/base/attributes.h) 进行注释（或 `constexpr`，但这应该很少见）：

```C++
ABSL_CONST_INIT thread_local Foo foo = ...;
```

函数内的 `thread_local` 变量没有初始化问题，但在线程退出期间仍然存在释放后使用的风险。请注意，您可以通过定义公开它的函数或静态方法来使用函数范围 `thread_local` 来模拟类或命名空间范围 `thread_local` ：

```C++
Foo& MyThreadLocalFoo() {
thread_local Foo 结果 = ComplicatedInitialization();
返回结果；
}
```

请注意，每当线程退出时， `thread_local` 变量都会被销毁。如果任何此类变量的析构函数引用任何其他（可能被破坏的） `thread_local` ，我们将遇到难以诊断释放后使用错误的问题。更喜欢简单类型，或者在销毁时可证明不运行用户提供的代码的类型，以最大程度地减少访问任何其他 `thread_local` 的可能性。

`thread_local` 应该优先于定义线程本地数据的其他机制。

# 课程

类是 C++ 中代码的基本单元。当然，我们广泛使用它们。本节列出了编写课程时应遵循的主要注意事项。

## 在构造函数中工作

避免在构造函数中调用虚拟方法，并避免在无法发出错误信号时可能失败的初始化。

可以在构造函数主体中执行任意初始化。

- 无需担心类是否已初始化。
- 通过构造函数调用完全初始化的对象可以是 `const` ，并且也可能更容易与标准容器或算法一起使用。

- 如果工作调用虚函数，这些调用将不会被分派到子类实现。即使您的类当前没有子类化，将来对您的类的修改也会悄悄地引入此问题，从而造成很多混乱。
- 构造函数没有简单的方法来发出错误信号，除非使程序崩溃（并不总是合适）或使用异常（_禁止_）。
- 如果工作失败，我们现在有一个初始化代码失败的对象，因此它可能是一个不寻常的状态，需要 `bool IsValid()` 状态检查机制（或类似的），很容易忘记调用。
- 您无法获取构造函数的地址，因此构造函数中完成的任何工作都不能轻易地传递给其他线程等。

构造函数永远不应该调用虚函数。如果适合您的代码，终止程序可能是适当的错误处理响应。否则，请考虑使用工厂函数或 `Init()` 方法，如 [TotW #42](https://abseil.io/tips/42) 中所述。避免在没有其他状态影响公共方法调用的对象上使用 `Init()` 方法（这种形式的半构造对象特别难以正确使用）。

## 隐式转换

不要定义隐式转换。对转换运算符和单参数构造函数使用 `explicit` 关键字。

隐式转换允许在需要不同类型（称为目标类型）的地方使用一种类型（称为源类型）的对象，例如将 `int` 参数传递给采用 `double` 参数的函数时。

除了语言定义的隐式转换之外，用户还可以通过将适当的成员添加到源或目标类型的类定义中来定义自己的隐式转换。源类型中的隐式转换由以目标类型命名的类型转换运算符定义（例如 `operator bool()` ）。目标类型中的隐式转换由构造函数定义，该构造函数可以将源类型作为其唯一参数（或唯一没有默认值的参数）。

 `explicit` 关键字可以应用于构造函数或转换运算符，以确保它只能在使用时目标类型是显式的（例如，通过强制转换）时使用。这不仅适用于隐式转换，还适用于列表初始化语法：

```C++
类 Foo {
显式 Foo(int x, double y);
...
};

void Func(Foo f);
```

**错误代码**

```C++
函数({42, 3.14}); // 错误
```

从技术上讲，这种代码并不是隐式转换，但就 `显式` 而言，该语言将其视为一种隐式转换。

- 隐式转换可以消除在明显时显式命名类型的需要，从而使类型更可用且更具表现力。
- 隐式转换可以是重载的更简单替代方案，例如当带有 `string_view` 参数的单个函数取代 `std::string` 和 `const char*` 的单独重载时。
- 列表初始化语法是一种简洁且富有表现力的初始化对象的方式。

- 隐式转换可以隐藏类型不匹配的错误，其中目标类型与用户的期望不匹配，或者用户不知道将发生任何转换。
- 隐式转换会使代码更难阅读，特别是在存在重载的情况下，因为它使实际调用的代码变得不那么明显。
- 采用单个参数的构造函数可能会意外地用作隐式类型转换，即使它们无意这样做。
- 当单参数构造函数未标记为 `显式` 时，没有可靠的方法来判断它是否打算定义隐式转换，或者作者只是忘记标记它。
- 隐式转换可能会导致调用点歧义，尤其是当存在双向隐式转换时。这可能是由于两种类型都提供隐式转换造成的，也可能是由于单一类型同时具有隐式构造函数和隐式类型转换运算符造成的。
- 如果目标类型是隐式的，列表初始化可能会遇到同样的问题，特别是如果列表只有一个元素。

类型转换运算符和可使用单个参数调用的构造函数必须在类定义中标记为 `显式` 。作为例外，复制和移动构造函数不应该是 `显式的` ，因为它们不执行类型转换。

对于设计为可互换的类型，隐式转换有时是必要且适当的，例如，当两种类型的对象只是同一基础值的不同表示时。在这种情况下，请联系您的项目负责人请求豁免此规则。

不能使用单个参数调用的构造函数可能会省略 `显式` 。采用单个 `std::initializer_list` 参数的构造函数也应该省略 `explicit`，以支持复制初始化（例如，`MyType m = {1, 2};`）。

## 可复制和可移动类型

类的公共 API 必须明确该类是可复制、只能移动还是既不可复制又不可移动。如果复制和/或移动这些操作对于您的类型来说清晰且有意义，则支持这些操作。

可移动类型是一种可以从临时类型初始化和分配的类型。

可复制类型是一种可以从相同类型的任何其他对象初始化或分配的类型（因此根据定义也可以移动），前提是源的值不更改。 `std::unique_ptr<int>` 是可移动但不可复制类型的示例（因为源 `std::unique_ptr<int>` 的值必须在分配给目标期间修改）。 `int` 和 `std::string` 是可复制的可移动类型的示例。 （对于 `int` ，移动和复制操作是相同的；对于 `std::string` ，存在比复制更便宜的移动操作。）

对于用户定义类型，复制行为由复制构造函数和复制赋值运算符定义。移动行为由移动构造函数和移动赋值运算符（如果存在）定义，否则由复制构造函数和复制赋值运算符定义。

在某些情况下，例如，按值传递对象时，编译器可以隐式调用复制/移动构造函数。

可复制和可移动类型的对象可以按值传递和返回，这使得 API 更简单、更安全、更通用。与通过指针或引用传递对象不同，不存在所有权、生命周期、可变性和类似问题的混淆风险，并且无需在合约中指定它们。它还可以防止客户端和实现之间的非本地交互，这使得编译器更容易理解、维护和优化它们。此外，此类对象可以与需要按值传递的通用 API（例如大多数容器）一起使用，并且它们允许在类型组合等方面提供额外的灵活性。

复制/移动构造函数和赋值运算符通常比 `Clone()` 、 `CopyFrom()` 或 `Swap()` 等替代方法更容易正确定义，因为它们可以由编译器隐式或使用 `=默认` 生成`。它们很简洁，并确保复制所有数据成员。复制和移动构造函数通常也更高效，因为它们不需要堆分配或单独的初始化和赋值步骤，并且它们有资格进行优化，例如[复制省略](http://en.cppreference.com/w /cpp/语言/copy_elision）。

移动操作允许从右值对象隐式且高效地转移资源。在某些情况下，这允许更简单的编码风格。

某些类型不需要是可复制的，并且为此类类型提供复制操作可能会令人困惑、无意义或完全不正确。表示单例对象（ `Registerer` ）、与特定范围相关的对象（ `Cleanup` ）或与对象标识紧密耦合（ `Mutex` ）的类型无法进行有意义的复制。要以多态方式使用的基类类型的复制操作是危险的，因为使用它们可能会导致[对象切片](https://en.wikipedia.org/wiki/Object_slicing)。默认或粗心实施的复制操作可能不正确，并且产生的错误可能令人困惑且难以诊断。

复制构造函数是隐式调用的，这使得调用很容易被错过。对于习惯使用传统或强制传递引用的语言的程序员来说，这可能会造成混乱。它还可能鼓励过度复制，从而导致性能问题。

每个类的公共接口必须明确该类支持哪些复制和移动操作。这通常应采取在声明的 `public` 部分中显式声明和/或删除适当操作的形式。

具体来说，可复制类应显式声明复制操作，仅移动类应显式声明移动操作，不可复制/可移动类应显式删除复制操作。可复制类还可以声明移动操作以支持高效移动。允许显式声明或删除所有四个复制/移动操作，但不是必需的。如果您提供复制或移动赋值运算符，则还必须提供相应的构造函数。

```C++
类可复制{
民众：
可复制（常量可复制&其他）=默认；
可复制&运算符=(const可复制&其他)=默认值；

// 隐式移动操作被上面的声明抑制。
// 您可以显式声明移动操作以支持高效的移动。
};

类仅移动{
民众：
MoveOnly(MoveOnly&& 其他) = 默认;
MoveOnly& 运算符=(MoveOnly&& 其他) = 默认；

// 复制操作被隐式删除，但是你可以
// 如果你愿意的话，明确地拼写出来：
MoveOnly(const MoveOnly&) = 删除;
MoveOnly& 运算符=(const MoveOnly&) = 删除;
};

类NotCopyableOrMovable {
民众：
// 不可复制或移动
NotCopyableOrMovable(const NotCopyableOrMovable&) = 删除;
NotCopyableOrMovable& 运算符=(const NotCopyableOrMovable&)
= 删除；

// 移动操作被隐式禁用，但您可以
// 如果你愿意的话，明确地拼写出来：
NotCopyableOrMovable(NotCopyableOrMovable&&) = 删除;
NotCopyableOrMovable& 运算符=(NotCopyableOrMovable&&)
= 删除；
};
```

这些声明/删除只有在显而易见时才可以省略：

- 如果类没有 `私有` 部分，例如 [struct](#Structs_vs._Classes) 或仅接口基类，则可复制性/可移动性可以由任何公共数据成员的可复制性/可移动性来确定。
- 如果基类显然不可复制或可移动，则派生类自然也不会。将这些操作隐式保留的仅接口基类不足以使具体子类变得清晰。
- 请注意，如果显式声明或删除复制的构造函数或赋值操作，则另一个复制操作并不明显，必须声明或删除。对于移动操作也是如此。

如果临时用户不清楚复制/移动的含义，或者会产生意外成本，则类型不应是可复制/移动的。可复制类型的移动操作严格来说是一种性能优化，并且是错误和复杂性的潜在来源，因此请避免定义它们，除非它们比相应的复制操作更有效。如果您的类型提供复制操作，建议您设计您的类，以便这些操作的默认实现是正确的。请记住像检查任何其他代码一样检查任何默认操作的正确性。

为了消除切片的风险，最好将基类抽象化，方法是保护它们的构造函数、声明它们的析构函数受保护，或者为它们提供一个或多个纯虚拟成员函数。最好避免从具体类派生。

## 结构与类

仅对携带数据的被动对象使用 `struct` ；其他一切都是一个 `类` 。

 `struct` 和 `class` 关键字在 C++ 中的行为几乎相同。我们为每个关键字添加我们自己的语义，因此您应该为您定义的数据类型使用适当的关键字。

 `结构` 应用于携带数据的被动对象，并且可能具有关联的常量。所有字段都必须是公共的。该结构不得具有暗示不同字段之间关系的不变量，因为用户直接访问这些字段可能会破坏这些不变量。可能存在构造函数、析构函数和辅助方法；但是，这些方法不得要求或强制执行任何不变量。

如果需要更多功能或不变量， `类` 更合适。如果有疑问，请将其设为 `类` 。

为了与 STL 保持一致，您可以对无状态类型使用 `struct` 而不是 `class` ，例如特征、_模板元函数_和一些函子。

请注意，结构和类中的成员变量具有_不同的命名规则_。

## 结构体与对和元组

只要元素可以具有有意义的名称，就更愿意使用 `结构` 而不是一对或元组。

虽然使用对和元组可以避免定义自定义类型的需要，可能会在编写代码时节省工作量，但在读取代码时，有意义的字段名称几乎总是比 `.first` 、 `.second` 或 `std` 更清晰： :获取<X>`。虽然 C++14 引入 `std::get<Type>` 通过类型而不是索引（当类型唯一时）访问元组元素有时可以部分缓解这种情况，但字段名称通常比一种。

对和元组可能适用于通用代码，其中对或元组的元素没有特定含义。为了与现有代码或 API 进行互操作，也可能需要使用它们。

## 继承

组合通常比继承更合适。使用继承时，请将其设置为 `public` 。

当子类继承基类时，它包含基类定义的所有数据和操作的定义。  `接口继承` 是从纯抽象基类（没有状态或定义的方法）继承；所有其他继承都是 `实现继承` 。

实现继承通过重用基类代码来减少代码大小，因为它专用于现有类型。因为继承是编译时声明，所以您和编译器可以理解操作并检测错误。接口继承可用于以编程方式强制类公开特定的 API。同样，在本例中，当类未定义 API 的必要方法时，编译器可以检测到错误。

对于实现继承，由于实现子类的代码分布在基类和子类之间，因此理解实现可能会更加困难。子类不能重写非虚拟函数，因此子类不能更改实现。

多重继承尤其成问题，因为它常常会带来更高的性能开销（事实上，从单继承到多重继承的性能下降往往会大于从普通分派到虚拟分派的性能下降），而且因为它有导致 `钻石` 的风险。  `继承模式很容易出现歧义、混乱和彻底的错误。

所有继承都应该是 `public` 。如果您想进行私有继承，则应该将基类的实例作为成员包含在内。当您不打算支持将类用作基类时，您可以在类上使用 `final` 。

不要过度使用实现继承。构图往往更合适。尝试将继承的使用限制在 `is-a` 的情况下：如果可以合理地说 `Bar`  `是一种`  `Foo` ，则 `Bar` 是 `Foo` 的子类。

将 `protected` 的使用限制为那些可能需要从子类访问的成员函数。请注意，[数据成员应该是 `私有` ](#Access_Control)。

使用 `override` 或（不太频繁） `final` 说明符之一明确注释虚拟函数或虚拟析构函数的覆盖。声明覆盖时不要使用 `virtual` 。基本原理：标记为 `override` 或 `final` 的函数或析构函数不是基类虚函数的重写，将无法编译，这有助于捕获常见错误。说明符充当文档；如果不存在说明符，则读者必须检查相关类的所有祖先以确定该函数或析构函数是否是虚拟的。

允许多重继承，但强烈建议不要多重_实现_继承。

## 运算符重载

明智地重载操作员。不要使用用户定义的文字。

C++ 允许用户代码使用 `operator` 关键字[声明内置运算符的重载版本](http://en.cppreference.com/w/cpp/language/operators)，只要参数之一是用户定义的类型。 `operator` 关键字还允许用户代码使用 `operator""` 定义新类型的文字，并定义类型转换函数，例如 `operator bool()`。

运算符重载可以使用户定义类型的行为与内置类型相同，从而使代码更加简洁和直观。重载运算符是某些操作的惯用名称（例如 `==` 、 `<` 、 `=` 和 `<<` ），遵守这些约定可以使用户定义的类型更具可读性并使它们能够互操作与期望这些名称的库。

用户定义的文字是用于创建用户定义类型的对象的非常简洁的表示法。

- 提供一组正确、一致且不出意外的操作符重载需要小心谨慎，否则可能会导致混乱和错误。
- 过度使用运算符可能会导致代码混乱，特别是在重载运算符的语义不遵循约定的情况下。
- 函数重载的危险与运算符重载同样存在，甚至更严重。
- 运算符重载可能会欺骗我们的直觉，让我们认为昂贵的操作是廉价的内置操作。
- 查找重载运算符的调用站点可能需要一个了解 C++ 语法的搜索工具，而不是 grep 等。
- 如果重载运算符的参数类型错误，您可能会得到不同的重载而不是编译器错误。例如， `foo < bar` 可能做一件事，而 `&foo < &bar` 则做完全不同的事情。
- 某些操作员过载本质上是危险的。重载一元 `&` 可能会导致相同的代码具有不同的含义，具体取决于重载声明是否可见。 `&&`、`||` 和 `,`（逗号）的重载无法匹配内置运算符的求值顺序语义。
- 运算符通常在类之外定义，因此存在不同文件引入同一运算符的不同定义的风险。如果两个定义都链接到同一个二进制文件中，则会导致未定义的行为，这可能表现为微妙的运行时错误。
- 用户定义的文字 (UDL) 允许创建即使是经验丰富的 C++ 程序员也不熟悉的新语法形式，例如作为 `std::string_view("Hello World")` 的简写的 `"Hello World"sv`。现有的符号更清晰，但不太简洁。
- 因为它们不能是命名空间限定的，所以 UDL 的使用还需要使用 using 指令（_我们禁止_）或 using-声明（_我们在头文件中禁止_，除非导入的名称是由有问题的头文件）。鉴于头文件必须避免 UDL 后缀，我们更愿意避免头文件和源文件之间的文字约定不同。

仅当重载运算符的含义显而易见、不令人意外且与相应的内置运算符一致时，才定义它们。例如，使用 `|` 作为按位或逻辑或，而不是作为外壳式管道。

仅在您自己的类型上定义运算符。更准确地说，将它们定义在与它们所操作的类型相同的标头、 `.cc` 文件和命名空间中。这样，无论类型在哪里，运算符都可用，从而最大限度地降低了多重定义的风险。如果可能，请避免将运算符定义为模板，因为它们必须对于任何可能的模板参数满足此规则。如果您定义了运算符，请同时定义任何有意义的相关运算符，并确保它们的定义一致。例如，如果您重载 `<` ，请重载所有比较运算符，并确保 `<` 和 `>` 对于相同的参数永远不会返回 true。

更喜欢将非修改二元运算符定义为非成员函数。如果将二元运算符定义为类成员，则隐式转换将应用于右侧参数，但不适用于左侧参数。如果 `a < b` 编译但 `b < a` 不编译，这会让你的用户感到困惑。

不要竭尽全力避免定义运算符重载。例如，更喜欢定义 `==` 、 `=` 和 `<<` ，而不是 `Equals()` 、 `CopyFrom()` 和 `PrintTo()` 。相反，不要仅仅因为其他库需要它们就定义运算符重载。例如，如果您的类型没有自然顺序，但您想将其存储在 `std::set` 中，请使用自定义比较器而不是重载 `<` 。

不要重载 `&&`、`||`、`,`（逗号）或一元 `&`。不要重载`operator""`，即不要引入用户定义的文字。不要使用其他人（包括标准库）提供的任何此类文字。

_隐式转换_部分介绍了类型转换运算符。  `=` 运算符在 `复制构造函数` 部分中进行了介绍。 _streams_ 部分介绍了重载 `<<` 以与流一起使用。另请参阅_函数重载_的规则，这些规则也适用于运算符重载。

## 访问控制

将类的数据成员设置为 `私有` ，除非它们是_常量_。这简化了关于不变量的推理，但如果需要的话，代价是一些以访问器（通常是 `const` ）形式的简单样板。

出于技术原因，我们允许在使用 [Google Test](https://github.com/google/googletest) 时 `保护`  `.cc` 文件中定义的测试夹具类的数据成员。如果测试装置类是在使用它的 `.cc` 文件之外定义的，例如在 `.h` 文件中，请将数据成员设置为 `private` 。

## 申报单

将类似的声明组合在一起，将 `公共` 部分放在前面。

类定义通常应以 `public:` 部分开头，然后是 `protected:` ，然后是 `private:` 。省略空的部分。

在每个部分中，更喜欢将类似类型的声明分组在一起，并且更喜欢以下顺序：

1. 类型和类型别名（`typedef`、`using`、`enum`、嵌套结构和类以及 `friend` 类型）
2.（可选，仅适用于结构）非 `静态` 数据成员
3. 静态常量
4. 工厂功能
5. 构造函数和赋值运算符
6. 析构函数
7. 所有其他函数（`static`和非`static`成员函数，以及`friend`函数）
8. 所有其他数据成员（静态和非静态）

不要将大型方法定义内联到类定义中。通常，只有琐碎或性能关键且非常短的方法可以内联定义。有关更多详细信息，请参阅_内联函数_。

# 功能

## 输入和输出

C++ 函数的输出自然是通过返回值提供的，有时也通过输出参数（或输入/输出参数）提供。

优先使用返回值而不是输出参数：它们提高了可读性，并且通常提供相同或更好的性能。

更喜欢按值返回，或者如果失败，则按引用返回。避免返回指针，除非它可以为空。

参数可以是函数的输入、函数的输出或两者。非可选输入参数通常应该是值或 `const` 引用，而非可选输出和输入/输出参数通常应该是引用（不能为空）。通常，使用 `std::Optional` 来表示可选的按值输入，并在非可选形式使用引用时使用 `const` 指针。使用非 const 指针来表示可选输出和可选输入/输出参数。

避免定义需要 `const` 引用参数才能比调用更有效的函数，因为 `const` 引用参数绑定到临时变量。相反，找到一种方法来消除生命周期要求（例如，通过复制参数），或者通过 `const` 指针传递它并记录生命周期和非空要求。

对函数参数进行排序时，请将所有仅输入参数放在任何输出参数之前。特别是，不要仅仅因为新参数是新的就在函数末尾添加新参数；将新的仅输入参数放在输出参数之前。这不是硬性规定。输入和输出参数都会使水变得浑浊，并且与往常一样，与相关函数的一致性可能需要您改变规则。可变参数函数也可能需要不寻常的参数排序。

## 编写短函数

喜欢小型且集中的功能。

我们认识到长函数有时是合适的，因此对函数长度没有硬性限制。如果一个函数超过大约 40 行，请考虑是否可以在不损害程序结构的情况下将其分解。

即使你的长函数现在工作得很好，几个月后有人修改它可能会添加新的行为。这可能会导致难以发现的错误。保持函数简短，可以让其他人更轻松地阅读和修改您的代码。小功能也更容易测试。

在使用某些代码时，您可能会发现又长又复杂的函数。不要被修改现有代码吓倒：如果使用这样的函数被证明很困难，您发现错误很难调试，或者您想在多个不同的上下文中使用其中的一部分，请考虑将该函数分解为更小的函数以及更易于管理的部分。

## 函数重载

仅当查看调用站点的读者可以很好地了解正在发生的情况而不必首先弄清楚正在调用哪个重载时，才使用重载函数（包括构造函数）。

您可以编写一个采用 `const std::string&` 的函数，并用另一个采用 `const char*` 的函数重载它。但是，在这种情况下，请考虑使用 `std::string_view` 。

```C++
类我的类{
民众：
void 分析(const std::string &text);
void 分析(const char *text, size_t textlen);
};
```

重载允许同名函数采用不同的参数，从而使代码更加直观。对于模板化代码来说可能是必需的，并且对于访问者来说可能很方便。

基于 `const` 或 ref 限定的重载可能会使实用程序代码更可用、更高效，或两者兼而有之。 （有关更多信息，请参阅 [TotW 148](http://abseil.io/tips/148)。）

如果函数仅由参数类型重载，读者可能必须了解 C++ 复杂的匹配规则才能知道发生了什么。如果派生类仅覆盖函数的某些变体，许多人也会对继承的语义感到困惑。

当变体之间不存在语义差异时，您可以重载函数。这些重载的类型、限定符或参数计数可能有所不同。但是，此类调用的读者不必知道选择了重载集中的哪个成员，只需知道正在调用该集中的**某些内容**即可。如果您可以使用标题中的单个注释来记录重载集中的所有条目，那么这是一个很好的迹象，表明它是一个设计良好的重载集。

## 默认参数

当保证默认值始终具有相同的值时，非虚函数上允许使用默认参数。遵循与_函数重载_相同的限制，并且如果使用默认参数获得的可读性不超过下面的缺点，则更喜欢重载函数。

通常您有一个使用默认值的函数，但有时您想覆盖默认值。默认参数提供了一种简单的方法来做到这一点，而无需为罕见的异常定义许多函数。与重载函数相比，默认参数具有更清晰的语法、更少的样板文件以及 `必需` 和 `可选` 参数之间更清晰的区别。

默认参数是实现重载函数语义的另一种方法，因此所有不重载函数的原因都适用。

虚拟函数调用中参数的默认值由目标对象的静态类型确定，并且不能保证给定函数的所有重写都声明相同的默认值。

默认参数会在每个调用站点重新计算，这会使生成的代码变得臃肿。读者可能还期望默认值在声明时固定，而不是在每次调用时变化。

在存在默认参数的情况下，函数指针会令人困惑，因为函数签名通常与调用签名不匹配。添加函数重载可以避免这些问题。

默认参数在虚拟函数中被禁止，因为它们无法正常工作，并且在指定的默认值可能不会根据计算时间而计算出相同值的情况下。 （例如，不要写 `void f(int n = counter++);` 。）

在其他一些情况下，默认参数可以提高其函数声明的可读性，足以克服上述缺点，因此它们是允许的。如有疑问，请使用重载。

## 尾随返回类型语法

仅当使用普通语法（前导返回类型）不切实际或可读性较差时才使用尾随返回类型。

C++ 允许两种不同形式的函数声明。在旧的形式中，返回类型出现在函数名称之前。例如：

```C++
int foo(int x);
```

较新的形式在函数名称之前使用 `auto` 关键字，在参数列表之后使用尾随返回类型。例如，上面的声明可以等效地写成：

```C++
自动 foo(int x) -> int;
```

尾随返回类型在函数的范围内。这对于像 `int` 这样的简单情况没有什么影响，但对于更复杂的情况很重要，例如在类作用域中声明的类型或根据函数参数编写的类型。

尾随返回类型是显式指定 _lambda 表达式_ 返回类型的唯一方法。在某些情况下，编译器能够推断出 lambda 的返回类型，但并非在所有情况下都如此。即使编译器可以自动推导它，有时显式指定它对读者来说会更清楚。

有时，在函数的参数列表已经出现之后指定返回类型会更容易且更具可读性。当返回类型取决于模板参数时尤其如此。例如：

```C++
模板 <类型名称 T，类型名称 U>
自动添加(T t, U u) -> decltype(t + u);
```

相对

```C++
模板 <类型名称 T，类型名称 U>
decltype(declval<T&>() + declval<U&>()) add(T t, U u);
```

尾随返回类型语法相对较新，在 C 和 Java 等类 C++ 语言中没有类似的语法，因此有些读者可能会觉得陌生。

现有的代码库有大量的函数声明，不会更改以使用新语法，因此实际的选择是仅使用旧语法或混合使用两者。使用单一版本更有利于风格的统一。

在大多数情况下，继续使用旧的函数声明样式，其中返回类型位于函数名称之前。仅在需要时（例如 lambda）或通过将类型放在函数参数列表之后，允许您以更易读的方式编写类型，才使用新的尾随返回类型形式。后一种情况应该很少见；这主要是相当复杂的模板代码中的一个问题，在大多数情况下是不鼓励的。

# Google 特有的魔法

我们使用各种技巧和实用程序来使 C++ 代码更加健壮，并且我们使用 C++ 的各种方式可能与您在其他地方看到的不同。

## 所有权和智能指针

对于动态分配的对象，更喜欢拥有单一、固定的所有者。更喜欢使用智能指针转移所有权。

 `所有权` 是一种用于管理动态分配的内存（和其他资源）的簿记技术。动态分配对象的所有者是一个对象或函数，负责确保不再需要时将其删除。所有权有时可以共享，在这种情况下，最后一个所有者通常负责删除它。即使所有权不共享，也可以将其从一段代码转移到另一段代码。

 `智能` 指针是像指针一样工作的类，例如，通过重载 `*` 和 `->` 运算符。某些智能指针类型可用于自动进行所有权簿记，以确保满足这些职责。 [`std::unique_ptr`](http://en.cppreference.com/w/cpp/memory/unique_ptr) 是一种智能指针类型，表示动态分配对象的独占所有权；当 `std::unique_ptr` 超出范围时，该对象将被删除。它无法复制，但可以_移动_以表示所有权转移。 [`std::shared_ptr`](http://en.cppreference.com/w/cpp/memory/shared_ptr) 是一种智能指针类型，表示动态分配对象的共享所有权。 `std::shared_ptr` 可以被复制；该对象的所有权在所有副本之间共享，并且当最后一个 `std::shared_ptr` 被销毁时该对象被删除。

- 如果没有某种所有权逻辑，实际上不可能管理动态分配的内存。
- 转移对象的所有权可能比复制它更便宜（如果甚至可以复制）。
- 转移所有权比 `借用` 指针或引用更简单，因为它减少了协调两个用户之间对象生命周期的需要。
- 智能指针可以通过使所有权逻辑明确、自记录且明确来提高可读性。
- 智能指针可以消除手动所有权簿记，简化代码并排除大量错误。
- 对于 `const` 对象，共享所有权可以是深度复制的简单而有效的替代方案。

- 所有权必须通过指针（无论是智能指针还是普通指针）来表示和转移。指针语义比值语义更复杂，尤其是在 API 中：您不仅要担心所有权，还要担心别名、生命周期和可变性等问题。
- 值语义的性能成本通常被高估，因此所有权转移的性能优势可能无法证明可读性和复杂性成本的合理性。
- 转移所有权的 API 迫使其客户端采用单一内存管理模型。
- 使用智能指针的代码对于资源释放发生的位置不太明确。
- `std::unique_ptr` 使用移动语义表达所有权转移，这是相对较新的，可能会让一些程序员感到困惑。
- 共享所有权可能是仔细所有权设计的诱人替代方案，从而混淆了系统的设计。
- 共享所有权需要在运行时进行明确的簿记，这可能成本高昂。
- 在某些情况下（例如，循环引用），具有共享所有权的对象可能永远不会被删除。
- 智能指针并不能完美替代普通指针。

如果需要动态分配，最好保留分配它的代码的所有权。如果其他代码需要访问该对象，请考虑向其传递副本，或传递指针或引用而不转移所有权。更喜欢使用 `std::unique_ptr` 来明确所有权转移。例如：

```C++
std::unique_ptr<Foo> FooFactory();
void FooConsumer(std::unique_ptr<Foo> ptr);
```

如果没有充分的理由，请勿将代码设计为使用共享所有权。其中一个原因是避免昂贵的复制操作，但只有在性能优势显着并且底层对象是不可变的（即 `std::shared_ptr<const Foo>` ）时才应该这样做。如果您确实使用共享所有权，请优先使用 `std::shared_ptr` 。

切勿使用 `std::auto_ptr` 。相反，请使用 `std::unique_ptr` 。

## cplint

使用 `cpplint.py` 来检测样式错误。

`cpplint.py` 是一个读取源文件并识别许多样式错误的工具。它并不完美，并且存在误报和误报，但它仍然是一个有价值的工具。

有些项目有关于如何从项目工具运行 `cpplint.py` 的说明。如果您参与的项目没有，您可以单独下载 [`cpplint.py`](https://raw.githubusercontent.com/google/styleguide/gh-pages/cpplint/cpplint.py)。

# 其他 C++ 特性

## 右值参考

仅在下面列出的某些特殊情况下才使用右值引用。

右值引用是一种只能绑定到临时对象的引用类型。语法类似于传统的引用语法。例如， `void f(std::string&& s);` 声明一个函数，其参数是对 `std::string` 的右值引用。

当标记 `&&` 应用于函数参数中的非限定模板参数时，将应用特殊的模板参数推导规则。这样的引用称为转发引用。

- 定义移动构造函数（采用对类类型的右值引用的构造函数）可以移动值而不是复制它。例如，如果 `v1` 是 `std::vector<std::string>`，那么 `auto v2(std::move(v1))` 可能只会导致一些简单的指针操作，而不是复制一个大的指针数据量。在许多情况下，这可以带来重大的性能改进。
- 右值引用使得实现可移动但不可复制的类型成为可能，这对于没有合理的复制定义但您可能仍希望将它们作为函数参数传递、将它们放入容器等的类型非常有用。
- `std::move` 对于有效使用某些标准库类型是必要的，例如 `std::unique_ptr`。
- 使用右值引用标记的_转发引用_，可以编写一个通用函数包装器，将其参数转发到另一个函数，并且无论其参数是否是临时对象和/或常量，都可以工作。这称为 `完美转发` 。

- 右值引用尚未被广泛理解。像引用折叠和转发引用的特殊扣除规则这样的规则有些模糊。
- 右值引用经常被滥用。在签名中使用右值引用是违反直觉的，其中参数在函数调用后应具有有效的指定状态，或者不执行移动操作。

不要使用右值引用（或将 `&&` 限定符应用于方法），但以下情况除外：

- 您可以使用它们来定义移动构造函数和移动赋值运算符（如_可复制和可移动类型_中所述）。
- 您可以使用它们来定义逻辑上 `消耗`  `*this` 的 `&&` 限定方法，使其处于不可用或空状态。请注意，这仅适用于方法限定符（位于函数签名的右括号之后）；如果您想 `使用` 普通函数参数，最好按值传递它。
- 您可以将转发引用与 `[std::forward](http://en.cppreference.com/w/cpp/utility/forward)` 结合使用，以支持完美转发。
- 您可以使用它们来定义一对重载，例如一个重载采用 `Foo&&` ，另一个采用 `const Foo&` 。通常首选的解决方案只是按值传递，但重载的函数对有时会产生更好的性能，有时在需要支持多种类型的通用代码中是必需的。一如既往：如果您为了性能而编写更复杂的代码，请确保您有证据表明它确实有帮助。

## 朋友们

我们允许在合理范围内使用 `friend` 类和函数。

友元通常应该定义在同一个文件中，这样读者就不必在另一个文件中查找类的私有成员的用途。  `friend`  的常见用途是让 `FooBuilder` 类成为 `Foo` 的友元，以便它可以正确构造 `Foo` 的内部状态，而不将该状态暴露给世界。在某些情况下，使单元测试类成为它所测试的类的友元可能会很有用。

友元扩展但不破坏类的封装边界。在某些情况下，当您只想授予另一个类访问该成员的权限时，这比将成员设置为 `public` 要好。然而，大多数类应该仅通过其公共成员与其他类交互。

## 例外情况

我们不使用 C++ 异常。

- 异常允许应用程序的更高级别决定如何处理深度嵌套函数中 `不可能发生` 的故障，而无需对错误代码进行模糊且容易出错的记录。

- 大多数其他现代语言都使用异常。在 C++ 中使用它们将使其与其他人熟悉的 Python、Java 和 C++ 更加一致。

- 一些第三方 C++ 库使用异常，在内部关闭它们会使与这些库集成变得更加困难。
- 异常是构造函数失败的唯一原因。我们可以使用工厂函数或 `Init()` 方法来模拟这一点，但它们分别需要堆分配或新的 `无效` 状态。
- 异常在测试框架中非常方便。

- 当您向现有函数添加 `throw` 语句时，您必须检查其所有传递调用者。他们要么必须至少做出基本的异常安全保证，要么永远不能捕获异常并对程序因此终止感到满意。例如，如果 `f()` 调用 `g()` 调用 `h()` ，并且 `h` 引发 `f` 捕获的异常，则 `g` 必须小心，否则可能无法正确清理。
- 更一般地说，异常使得程序的控制流难以通过查看代码来评估：函数可能会在您不期望的地方返回。这会导致可维护性和调试困难。您可以通过一些有关如何以及在何处使用异常的规则来最小化此成本，但代价是开发人员需要了解和理解更多内容。
- 异常安全需要 RAII 和不同的编码实践。需要大量的支持机制才能轻松编写正确的异常安全代码。此外，为了避免要求读者理解整个调用图，异常安全代码必须将写入持久状态的逻辑隔离到 `提交` 阶段。这既有好处也有成本（也许您被迫混淆代码以隔离提交）。允许例外将迫使我们始终支付这些成本，即使它们不值得。
- 打开异常会将数据添加到生成的每个二进制文件中，从而增加编译时间（可能略有增加）并可能增加地址空间压力。
- 异常的可用性可能会鼓励开发人员在异常不合适时抛出异常，或者在不安全时从中恢复。例如，无效的用户输入不应导致引发异常。我们需要使样式指南更长来记录这些限制！

从表面上看，使用例外的好处大于成本，尤其是在新项目中。但是，对于现有代码，异常的引入会对所有相关代码产生影响。如果异常可以传播到新项目之外，那么将新项目集成到现有的无异常代码中也会出现问题。由于 Google 现有的大多数 C++ 代码都没有准备好处理异常，因此采用生成异常的新代码相对困难。

鉴于 Google 现有的代码不支持异常，因此使用异常的成本比新项目的成本要高一些。转换过程会很慢并且容易出错。我们认为异常的可用替代方案（例如错误代码和断言）不会带来重大负担。

我们反对使用例外的建议不是基于哲学或道德理由，而是基于实践。因为我们希望使用 Google 的开源项目，但如果这些项目使用异常，则很难做到这一点，因此我们也需要建议不要在 Google 开源项目中使用异常。如果我们必须从头开始，事情可能会有所不同。

此禁令也适用于与异常处理相关的功能，例如 `std::exception_ptr` 和 `std::nested_exception` 。

对于 Windows 代码，此规则有一个_例外_（无双关语意图）。

## `没有例外`

当 `noexcept` 有用且正确时指定它。

`noexcept` 说明符用于指定函数是否抛出异常。如果异常从标记为 `noexcept` 的函数中逃逸，程序将通过 `std::terminate` 崩溃。

`noexcept` 运算符执行编译时检查，如果声明表达式不抛出任何异常，则返回 true。

- 在某些情况下，将移动构造函数指定为 `noexcept` 可提高性能，例如，如果 T 的移动构造函数为 `noexcept` ，则 `std::vector<T>::resize()` 会移动而不是复制对象。
- 在函数上指定 `noexcept` 可以在启用异常的环境中触发编译器优化，例如，如果编译器知道不会由于 `noexcept` 说明符而引发任何异常，则它不必为堆栈展开生成额外的代码。

- 在遵循本指南的禁用异常的项目中，很难确保 `noexcept` 说明符是正确的，甚至很难定义正确性的含义。
- 撤消 `noexcept` 即使不是不可能，也很困难，因为它以难以检测的方式消除了调用者可能依赖的保证。

如果它准确地反映了函数的预期语义，即如果从函数体内以某种方式抛出异常，那么它代表一个致命错误，那么当它对性能有用时，您可以使用 `noexcept` 。您可以假设移动构造函数上的 `noexcept` 具有有意义的性能优势。如果您认为在某些其他函数上指定 `noexcept` 可以显着提高性能，请与您的项目负责人讨论。

如果完全禁用异常（即大多数 Google C++ 环境），则首选无条件 `noexcept` 。否则，请使用带有简单条件的条件 `noexcept` 说明符，仅在函数可能抛出异常的少数情况下评估 false。测试可能包括类型特征检查，检查所涉及的操作是否可能抛出（例如，对于移动构造对象，`std::is_nothrow_move_constructible`），或者分配是否可以抛出（例如，对于标准默认分配，`absl::default_allocator_is_nothrow`） 。请注意，在许多情况下，异常的唯一可能原因是分配失败（我们认为移动构造函数不应抛出异常，除非分配失败），并且在许多应用程序中，适合将内存耗尽视为致命错误而不是异常情况您的程序应该尝试从中恢复。即使对于其他潜在的故障，您也应该优先考虑接口的简单性，而不是支持所有可能的异常抛出场景：例如，不要编写依赖于哈希函数是否可以抛出的复杂的 `noexcept` 子句，而是简单地记录您的组件不支持哈希函数抛出并使其无条件 `noexcept` 。

## 运行时类型信息 (RTTI)

避免使用运行时类型信息 (RTTI)。

RTTI 允许程序员在运行时查询对象的 C++ 类。这是通过使用 `typeid` 或 `dynamic_cast` 来完成的。

RTTI 的标准替代方案（如下所述）需要修改或重新设计相关的类层次结构。有时，此类修改是不可行或不可取的，特别是在广泛使用或成熟的代码中。

RTTI 在某些单元测试中很有用。例如，它在工厂类的测试中很有用，其中测试必须验证新创建的对象是否具有预期的动态类型。它对于管理对象及其模拟之间的关系也很有用。

RTTI 在考虑多个抽象对象时非常有用。考虑

```C++
布尔基::等于(基*其他) = 0;
bool Derived::Equal(Base* other) {
派生* that =dynamic_cast<Derived*>(other);
if (that == nullptr)
返回假；
...
}
```

在运行时查询对象的类型通常意味着设计问题。在运行时需要知道对象的类型通常表明类层次结构的设计存在缺陷。

不规范地使用 RTTI 会使代码难以维护。它可能导致基于类型的决策树或 switch 语句分散在整个代码中，在进行进一步更改时必须检查所有这些。

RTTI 具有合法用途，但容易被滥用，因此使用时必须小心。您可以在单元测试中自由使用它，但在其他代码中尽可能避免使用它。特别是，在新代码中使用 RTTI 之前请三思。如果您发现自己需要编写根据对象的类而表现不同的代码，请考虑以下查询类型的替代方法之一：

- 虚拟方法是根据特定子类类型执行不同代码路径的首选方式。这将工作置于对象本身内。
- 如果工作属于对象之外，而是在某些处理代码中，请考虑双重分派解决方案，例如访问者设计模式。这允许对象本身外部的工具使用内置类型系统来确定类的类型。

当程序的逻辑保证基类的给定实例实际上是特定派生类的实例时，则可以在该对象上自由使用 `dynamic_cast` 。在这种情况下，通常可以使用 `static_cast` 作为替代方案。

基于类型的决策树强烈表明您的代码走错了路。

**错误代码**

```C++
if (typeid(*data) == typeid(D1)) {
...
} else if (typeid(*data) == typeid(D2)) {
...
} else if (typeid(*data) == typeid(D3)) {
...
```

当向类层次结构中添加其他子类时，此类代码通常会中断。而且，当子类的属性发生变化时，很难找到并修改所有受影响的代码段。

不要手动实现类似 RTTI 的解决方法。反对 RTTI 的论点同样适用于像带有类型标签的类层次结构这样的解决方法。此外，变通办法掩盖了你的真实意图。

## 选角

使用 C++ 风格的强制转换，如 `static_cast<float>(double_value)` ，或使用大括号初始化来转换算术类型，如 `int64_t y = int64_t{1} << 42` 。不要使用像 `(int)x` 这样的转换格式，除非转换为 `void` 。仅当 `T` 是类类型时，才可以使用 `T(x)` 等强制转换格式。

C++ 引入了与 C 不同的强制转换系统，用于区分强制转换操作的类型。

C 类型转换的问题是操作的模糊性；有时你正在做一个_conversion_（例如，`(int)3.5`），有时你正在做一个_cast_（例如，`(int)"hello"`）。大括号初始化和 C++ 强制转换通常可以帮助避免这种歧义。此外，C++ 强制转换在搜索时更加明显。

C++ 风格的转换语法冗长且麻烦。

一般来说，不要使用 C 风格的强制转换。相反，当需要显式类型转换时，请使用这些 C++ 样式的强制转换。

- 使用大括号初始化来转换算术类型（例如，`int64_t{x}`）。这是最安全的方法，因为如果转换可能导致信息丢失，代码将无法编译。语法也很简洁。
- 使用 `absl::implicit_cast` 安全地转换类型层次结构，例如，将 `Foo*` 转换为 `SuperclassOfFoo*` 或将 `Foo*` 转换为 `const Foo*` 。 C++ 通常会自动执行此操作，但某些情况需要显式向上转换，例如使用 `?:` 运算符。
- 当您需要将指针从类显式向上转换为其超类时，或者当您需要将指针从超类显式转换为子类。在最后一种情况下，您必须确保您的对象实际上是子类的实例。
- 使用 `const_cast` 删除 `const` 限定符（参见 _const_）。
- 使用 `reinterpret_cast` 对指针类型与整数和其他指针类型（包括 `void*` ）进行不安全的转换。仅当您知道自己在做什么并且了解别名问题时才使用此选项。另外，请考虑取消引用指针（不进行强制转换）并使用 `absl::bit_cast` 来强制转换结果值。
- 使用 `absl::bit_cast` 使用相同大小的不同类型（类型双关语）解释值的原始位，例如将 `double` 的位解释为 `int64_t` 。

有关使用 `dynamic_cast` 的指导，请参阅 [RTTI 部分](#Run-Time_Type_Information__RTTI_)。

## 流

在适当的地方使用流，并坚持 `简单` 的用法。仅对表示值的类型进行流式重载 `<<` ，并且仅写入用户可见的值，而不写入任何实现细节。

流是 C++ 中的标准 I/O 抽象，如标准头 `<iostream>` 所示。它们广泛用于 Google 代码中，主要用于调试日志记录和测试诊断。

可移植、可重用和可扩展的API 。相比之下， `printf` 甚至不支持 `std::string` ，更不用说用户定义的类型了，而且很难移植。 `printf` 还要求您在该函数的众多略有不同的版本中进行选择，并浏览数十个转换说明符。

流通过 `std::cin` 、 `std::cout` 、 `std::cerr` 和 `std::clog` 为控制台 I/O 提供一流的支持。 C API 也可以这样做，但由于需要手动缓冲输入而受到限制。

- 可以通过改变流的状态来配置流格式。此类突变是持久的，因此代码的行为可能会受到流的整个先前历史记录的影响，除非您每次其他代码可能触及它时都竭尽全力将其恢复到已知状态。用户代码不仅可以修改内置状态，还可以通过注册系统添加新的状态变量和行为。
- 由于上述问题、流代码中代码和数据混合的方式以及运算符重载的使用（可能会选择与您期望不同的重载），因此很难精确控制流输出。
- 通过 `<<` 运算符链构建输出的做法会干扰国际化，因为它将词序融入代码中，并且流对本地化的支持是[有缺陷的](http://www.boost.org/doc /libs/1_48_0/libs/locale/doc/html/rationale.html#rationale_why）。
- 流 API 微妙而复杂，因此程序员必须积累使用它的经验才能有效地使用它。
- 解决`<<`的许多重载对于编译器来说代价极高。当在大型代码库中普遍使用时，它可能会消耗多达 20% 的解析和语义分析时间。

仅当流是完成工作的最佳工具时才使用它们。当 I/O 是临时的、本地的、人类可读的并且针对其他开发人员而不是最终用户时，通常会出现这种情况。与您周围的代码以及整个代码库保持一致；如果有一个既定的工具可以解决您的问题，请改用该工具。特别是，对于诊断输出，日志记录库通常比 `std::cerr` 或 `std::clog` 更好，而 `absl/strings` 或类似库中的库通常比 `std::` 更好。字符串流`。

避免使用面向外部用户或处理不受信任数据的 I/O 流。相反，找到并使用适当的模板库来处理国际化、本地化和安全强化等问题。

如果您确实使用流，请避免使用流 API 的有状态部分（错误状态除外），例如 `imbue()` 、 `xalloc()` 和 `register_callback()` 。使用显式格式化函数（例如 `absl::StreamFormat()` ）而不是流操纵器或格式化标志来控制格式化细节，例如基数、精度或填充。

仅当您的类型表示一个值时，才将 `<<` 重载为您类型的流式运算符，并且 `<<` 会写出该值的人类可读字符串表示形式。避免在 `<<` 的输出中暴露实现细节；如果您需要打印对象内部结构以进行调试，请改用命名函数（名为 `DebugString()` 的方法是最常见的约定）。

## 预自增和预自减

除非需要后缀语义，否则请使用递增和递减运算符的前缀形式 (`++i`)。

当变量递增（`++i` 或 `i++`）或递减（`--i` 或 `i--`）并且不使用表达式的值时，必须决定是否预递增（递减）或后递增（递减）。

后缀递增/递减表达式的计算结果为 `修改前的值` 。这可能会导致代码更紧凑但更难阅读。前缀形式通常更具可读性，效率绝不会降低，而且效率更高，因为它不需要像操作之前那样复制值。

在 C 语言中，即使不使用表达式值，特别是在 `for` 循环中，也形成了使用后递增的传统。

使用前缀递增/递减，除非代码明确需要后缀递增/递减表达式的结果。

## 常量的使用

在 API 中，只要有意义就使用 `const` 。对于 const 的某些用途， `constexpr` 是更好的选择。

声明的变量和参数可以在关键字 `const` 前面，以指示变量不被更改（例如， `const int foo` ）。类函数可以具有 `const` 限定符来指示该函数不会更改类成员变量的状态（例如，`class Foo { int Bar(char c) const; };`）。

人们更容易理解变量是如何使用的。允许编译器进行更好的类型检查，并且可以想象生成更好的代码。帮助人们确信程序的正确性，因为他们知道他们调用的函数在修改变量的方式上受到限制。帮助人们了解在多线程程序中哪些函数可以安全使用而无需锁定。

`const` 具有病毒式传播：如果将 `const` 变量传递给函数，则该函数的原型中必须有 `const` （或者该变量将需要 `const_cast`）。调用库函数时这可能是一个特殊问题。

我们强烈建议在 API 中使用 `const` （即在函数参数、方法和非局部变量上），只要它有意义且准确。这提供了一致的、大部分经过编译器验证的文档，说明操作可以改变哪些对象。拥有一致且可靠的方法来区分读取和写入对于编写线程安全代码至关重要，并且在许多其他上下文中也很有用。尤其：

- 如果函数保证不会修改通过引用或指针传递的参数，则相应的函数参数应该是对 const 的引用（`const T&`）或对 const 的指针（`const T*`） ， 分别。
- 对于按值传递的函数参数， `const` 对调用者没有影响，因此不建议在函数声明中使用。请参阅 [TotW #109](https://abseil.io/tips/109)。
- 将方法声明为 `const` ，除非它们改变对象的逻辑状态（或允许用户修改该状态，例如，通过返回非 `const` 引用，但这种情况很少见），否则它们不能安全被同时调用。

既不鼓励也不阻止在局部变量上使用 `const` 。

类的所有 `const` 操作都应该可以安全地同时调用。如果这不可行，则必须将该类明确记录为 `线程不安全` 。

### const 放在哪里

有些人更喜欢 `int const *foo` 的形式而不是 `const int* foo` 。他们认为这更具可读性，因为它更一致：它保留了 `const` 始终遵循它所描述的对象的规则。然而，这一一致性参数不适用于具有很少深度嵌套指针表达式的代码库，因为大多数 `const` 表达式只有一个 `const` ，并且它适用于基础值。在这种情况下，无法保持一致性。将 `const` 放在前面可以说更具可读性，因为它遵循英语将 `形容词` （ `const` ）放在 `名词` （ `int` ）之前。

也就是说，虽然我们鼓励将 `const` 放在第一位，但我们并不要求它。但要与你周围的代码保持一致！

## constexpr 的使用

使用 `constexpr` 定义真正的常量或确保常量初始化。

某些变量可以声明为 `constexpr` 以指示这些变量是真正的常量，即在编译/链接时固定。某些函数和构造函数可以声明为 `constexpr` ，这使得它们能够用于定义 `constexpr` 变量。

使用 `constexpr` 可以使用浮点表达式来定义常量，而不仅仅是文字；用户定义类型常量的定义；以及带有函数调用的常量定义。

如果稍后必须降级，过早地将某些内容标记为 `constexpr` 可能会导致迁移问题。当前对 `constexpr` 函数和构造函数中允许的内容的限制可能会在这些定义中引发晦涩的解决方法。

`constexpr` 定义可以对接口的常量部分进行更稳健的规范。使用 constexpr 指定真正的常量以及支持其定义的函数。避免复杂化函数定义以使其能够与 `constexpr` 一起使用。不要使用 `constexpr` 强制内联。

## 整数类型

在 C++ 内置整数类型中，唯一使用的一种是 `int` 。如果程序需要不同大小的整数类型，请使用 `<cstdint>` 中的精确宽度整数类型，例如 `int16_t` 。如果您的值可能大于或等于 2^31，请使用 64 位类型，例如 `int64_t` 。请记住，即使您的值对于 `int` 来说不会太大，它也可能用于可能需要更大类型的中间计算。如有疑问，请选择较大的类型。

C++ 没有指定像 `int` 这样的整数类型的精确大小。当代架构上常见的大小是 16 位 `short` ，32 位 `int` ，32 或 64 位 `long` ，以及 64 位 `long long` ，但不同的平台有不同的选择，特别是 `long`  `。

声明的统一性。

C++ 中整型的大小可能因编译器和体系结构而异。

标准库头 `<cstdint>` 定义了 `int16_t`、`uint32_t`、`int64_t` 等类型。当您需要时，您应该始终优先使用这些类型而不是 `short`、`unsigned long long` 等对整数大小的保证。在内置整数类型中，仅应使用 `int` 。在适当的时候，欢迎您使用标准类型别名，例如 `size_t` 和 `ptrdiff_t` 。

我们经常使用 `int` ，因为我们知道整数不会太大，例如循环计数器。对于此类事情，请使用普通的旧 `int` 。您应该假设 `int` 至少为 32 位，但不要假设它超过 32 位。如果您需要 64 位整数类型，请使用 `int64_t` 或 `uint64_t` 。

对于我们知道可以 `大` 的整数，请使用 `int64_t` 。

您不应使用无符号整数类型，例如 `uint32_t` ，除非有正当理由（例如表示位模式而不是数字），或者您需要定义溢出模 2^N。特别是，不要使用无符号类型来表示数字永远不会为负数。相反，为此使用断言。

如果您的代码是返回大小的容器，请确保使用能够适应容器的任何可能用途的类型。如有疑问，请使用较大的类型而不是较小的类型。

转换整数类型时要小心。整数转换和提升可能会导致未定义的行为，从而导致安全错误和其他问题。

### 关于无符号整数

无符号整数适合表示位域和模算术。由于历史意外，C++ 标准也使用无符号整数来表示容器的大小 - 标准机构的许多成员认为这是一个错误，但目前实际上无法修复。事实上，无符号算术并不模拟简单整数的行为，而是由标准定义来模拟模块化算术（围绕上溢/下溢），这意味着编译器无法诊断一类重要的错误。在其他情况下，定义的行为会阻碍优化。

也就是说，混合整数类型的符号会导致同样大的一类问题。我们可以提供的最佳建议：尝试使用迭代器和容器而不是指针和大小，尝试不要混合符号性，并尝试避免无符号类型（表示位域或模算术除外）。不要仅仅使用无符号类型来断言变量是非负的。

## 64 位可移植性

代码应该对 64 位和 32 位友好。请记住打印、比较和结构对齐的问题。

- 某些整型类型定义的正确可移植 `printf()` 转换说明符依赖于宏扩展，我们发现这些宏扩展使用起来不愉快并且要求不切实际（来自 `<cinttypes>` 的 `PRI` 宏）。除非对于您的特定情况没有合理的替代方案，否则请尽量避免甚至升级依赖 `printf` 系列的 API。而是使用支持类型安全数字格式的库，例如 [`StrCat`](https://github.com/abseil/abseil-cpp/blob/master/absl/strings/str_cat.h) 或 [`Substitute`]( https://github.com/abseil/abseil-cpp/blob/master/absl/strings/substitute.h) 用于快速简单的转换，或 [`std::ostream`](#Streams)。

不幸的是， `PRI` 宏是指定标准位宽类型定义（例如 `int64_t` 、 `uint64_t` 、 `int32_t` 、 `uint32_t` 等）转换的唯一可移植方法。如果可能，请避免将位宽 typedef 指定的类型的参数传递给基于 `printf` 的 API。请注意，使用 printf 具有专用长度修饰符的 typedef 是可以接受的，例如 `size_t` （ `z` ）、 `ptrdiff_t` （ `t` ）和 `maxint_t` （ `j` ）。

- 请记住 `sizeof(void *)` != `sizeof(int)`。如果您想要一个指针大小的整数，请使用 `intptr_t` 。
- 您可能需要小心结构对齐，特别是对于存储在磁盘上的结构。默认情况下，任何具有 `int64_t`/`uint64_t` 成员的类/结构在 64 位系统上最终都是 8 字节对齐的。如果在磁盘上有这样的结构在 32 位和 64 位代码之间共享，则需要确保它们在两种体系结构上的打包方式相同。大多数编译器提供了一种改变结构对齐的方法。对于 gcc，您可以使用 `__attribute__((packed))`。 MSVC 提供 `#pragma pack()` 和 `__declspec(align())` 。
- 根据需要使用 [braced-initialization](#Casting) 创建 64 位常量。例如：

```C++
int64_t my_value{0x123456789}；
uint64_t my_mask{uint64_t{3} << 48}；
```

## 预处理器宏

避免定义宏，尤其是在标头中；更喜欢内联函数、枚举和 `const` 变量。使用特定于项目的前缀命名宏。不要使用宏来定义 C++ API 的各个部分。

宏意味着您看到的代码与编译器看到的代码不同。这可能会引入意外的行为，特别是因为宏具有全局作用域。

当宏用于定义 C++ API 的各个部分时，宏带来的问题尤其严重，对于公共 API 来说更是如此。当开发人员错误地使用该接口时，编译器发出的每条错误消息现在都必须解释宏如何形成接口。重构和分析工具更新界面的难度要大得多。因此，我们明确禁止以这种方式使用宏。例如，避免以下模式：

**错误代码**

```C++
类 WOMBAT_TYPE(Foo) {
// ...

民众：
EXPAND_PUBLIC_WOMBAT_API（Foo）

EXPAND_WOMBAT_COMPARISONS(Foo, ==, <)
};
```

幸运的是，宏在 C++ 中并不像在 C 中那样必要。不要使用宏来内联性能关键型代码，而是使用内联函数。不要使用宏来存储常量，而是使用 `const` 变量。不要使用宏来 `缩写` 长变量名，而是使用引用。不要使用宏来有条件地编译代码……好吧，根本不要这样做（当然，除了 `#define` 防护以防止头文件的双重包含）。它使测试变得更加困难。

宏可以做其他技术无法完成的事情，并且您确实在代码库中看到它们，尤其是在较低级别的库中。它们的一些特殊功能（如字符串化、连接等）无法通过语言本身获得。但在使用宏之前，请仔细考虑是否有非宏方法可以达到相同的结果。如果您需要使用宏来定义接口，请联系您的项目负责人请求放弃此规则。

以下使用模式将避免宏的许多问题；如果您使用宏，请尽可能遵循它：

- 不要在`.h`文件中定义宏。
- 在使用宏之前使用 `#define` 宏，在使用宏之后使用 `#undef` 宏。
- 在用您自己的宏替换之前，不要只是 `#undef` 现有的宏；相反，选择一个可能是唯一的名称。
- 尽量不要使用扩展为不平衡 C++ 结构的宏，或者至少很好地记录该行为。
- 最好不要使用 `##` 来生成函数/类/变量名称。

强烈建议不要从标头中导出宏（即在标头中定义它们，而不在标头末尾之前对其进行 `#undef` ）。如果确实从标头导出宏，则它必须具有全局唯一的名称。为了实现这一点，它必须使用由项目的命名空间名称（但大写）组成的前缀来命名。

## 0 和 nullptr/NULL

对指针使用 `nullptr` ，对字符使用 `\0` （而不是 `0` 文字）。

对于指针（地址值），请使用 `nullptr` ，因为这提供了类型安全。

使用 `\0` 作为空字符。使用正确的类型可以使代码更具可读性。

## 大小

更喜欢 `sizeof(varname)` 而不是 `sizeof(type)` 。

当您获取特定变量的大小时，请使用 `sizeof(varname)` 。如果有人现在或以后更改变量类型， `sizeof(varname)` 将适当更新。您可以将 `sizeof(type)` 用于与任何特定变量无关的代码，例如管理外部或内部数据格式的代码，其中不方便使用适当的 C++ 类型的变量。

```C++
我的结构数据；
memset(&data, 0, sizeof(data));
```

**错误代码**

```C++
memset(&data, 0, sizeof(MyStruct));
```

```C++
if (raw_size < sizeof(int)) {
LOG(ERROR) << `压缩记录不够大，无法计数：`  << raw_size;
返回假；
}
```

## 类型推导（包括auto）

仅当类型推导使不熟悉项目的读者更清楚代码或者使代码更安全时才使用类型推导。不要仅仅为了避免编写显式类型带来的不便而使用它。

在多种情况下，C++ 允许（甚至要求）编译器推导类型，而不是在代码中显式说明：

### [函数模板参数推导](https://en.cppreference.com/w/cpp/language/template_argument_deduction)

无需显式模板参数即可调用函数模板。编译器根据函数参数的类型推导这些参数：**neutralcode**

```C++
模板 <类型名称 T>
无效 f(T t);

f(0)； // 调用 f<int>(0)
```

### [`auto`变量声明](https://en.cppreference.com/w/cpp/language/auto)

变量声明可以使用 `auto` 关键字来代替类型。编译器从变量的初始值设定项推导类型，遵循与具有相同初始值设定项的函数模板参数推导相同的规则（只要不使用花括号而不是括号）。 **中性代码**

```C++
自动a=42； // a 是一个 int
自动& b = a; // b 是一个 int&
自动c=b； // c 是一个 int
自动d{42}； // d 是一个 int，而不是 std::initializer_list<int>
```

`auto` 可以用 `const` 限定，并且可以用作指针或引用类型的一部分，但不能用作模板参数。此语法的一个罕见变体使用 `decltype(auto)` 而不是 `auto`，在这种情况下，推导的类型是应用 [`decltype`](https://en.cppreference.com/w/cpp/ language/decltype) 到初始化器。

### [函数返回类型推导](https://en.cppreference.com/w/cpp/language/function#Return_type_deduction)

`auto`（和 `decltype(auto)`）也可以用来代替函数返回类型。编译器从函数体中的 `return` 语句推导出返回类型，遵循与变量声明相同的规则：**neutralcode**

```C++
自动 f() { 返回 0; } // f的返回类型是int
```

_Lambda 表达式_ 返回类型可以用相同的方式推导，但这是通过省略返回类型来触发的，而不是通过显式的 `auto` 来触发。令人困惑的是，函数的尾随返回类型语法也在返回类型位置使用 `auto` ，但这并不依赖于类型推导；它只是显式返回类型的替代语法。

### [通用 lambdas](https://isocpp.org/wiki/faq/cpp14-language#generic-lambdas)

lambda 表达式可以使用 `auto` 关键字代替其一个或多个参数类型。这导致 lambda 的调用运算符成为函数模板而不是普通函数，每个 `auto` 函数参数都有一个单独的模板参数： **neutralcode**

```C++
// 按降序对 `vec` 进行排序
std::sort(vec.begin(), vec.end(), [](auto lhs, auto rhs) { return lhs > rhs; });
```

### [Lambda 初始化捕获](https://isocpp.org/wiki/faq/cpp14-language#lambda-captures)

Lambda 捕获可以具有显式初始化程序，可用于声明全新的变量，而不仅仅是捕获现有变量：**中性代码**

```C++
[x = 42, y = "foo"] { ... } // x 是 int，y 是 const char*
```

此语法不允许指定类型；相反，它是使用 `auto` 变量的规则推导出来的。

### [类模板参数推导](https://en.cppreference.com/w/cpp/language/class_template_argument_deduction)

见下文_。

### [结构化绑定](https://en.cppreference.com/w/cpp/language/structured_binding)

当使用 auto 声明元组、结构体或数组时，您可以指定单个元素的名称，而不是整个对象的名称；这些名称称为 `结构化绑定` ，整个声明称为 `结构化绑定声明` 。此语法无法指定封闭对象或单个名称的类型：**neutralcode**

```C++
auto [iter, success] = my_map.insert({key, value});
如果（！成功）{
迭代->第二个=值；
}
```

`auto` 也可以用 `const`、`&` 和 `&&` 进行限定，但请注意，这些限定符在技术上适用于匿名元组/结构体/数组，而不是单个绑定。确定绑定类型的规则相当复杂；结果往往并不令人惊讶，只是即使声明声明了引用，绑定类型通常也不会是引用（但无论如何它们通常都会表现得像引用）。

（这些摘要省略了许多细节和警告；请参阅链接以获取更多信息。）

- C++ 类型名称可能又长又麻烦，尤其是当它们涉及模板或命名空间时。
- 当 C++ 类型名称在单个声明或小代码区域中重复时，重复可能不会提高可读性。
- 有时推导类型会更安全，因为这可以避免意外复制或类型转换的可能性。

当类型显式时，C++ 代码通常会更清晰，尤其是当类型推导依赖于代码中较远部分的信息时。在这样的表达中：

**错误代码**

```C++
自动 foo = x.add_foo();
自动 i = y.Find(key);
```

如果 `y` 的类型不太为人所知，或者 `y` 已在多行之前声明，那么结果类型可能并不明显。

程序员必须了解类型推导何时会或不会产生引用类型，否则他们会在无意时获得副本。

如果推导类型用作接口的一部分，那么程序员可能会在仅打算更改其值的同时更改其类型，从而导致比预期更彻底的 API 更改。

基本规则是：仅使用类型推导使代码更清晰或更安全，而不要仅仅为了避免编写显式类型的不便而使用它。在判断代码是否更清晰时，请记住，您的读者不一定是您的团队成员，也不一定熟悉您的项目，因此您和您的审阅者认为不必要的混乱的类型通常会为其他人提供有用的信息。例如，您可以假设 `make_unique<Foo>()` 的返回类型是显而易见的，但 `MyWidgetFactory()` 的返回类型可能不是。

这些原则适用于所有形式的类型推导，但细节有所不同，如以下各节所述。

### 函数模板参数推导

函数模板参数推导几乎总是可以的。类型推导是与函数模板交互的预期默认方式，因为它允许函数模板像无限的普通函数重载集一样工作。因此，函数模板的设计几乎总是使模板参数推导清晰且安全，否则无法编译。

### 局部变量类型推导

对于局部变量，可以使用类型推导，通过消除明显或不相关的类型信息来使代码更加清晰，以便读者可以专注于代码中有意义的部分：

**中性代码**

```C++
std::unique_ptr<WidgetWithBellsAndWhistles> 小部件 =
std::make_unique<WidgetWithBellsAndWhistles>(arg1, arg2);
Absl::flat_hash_map<std::string,
std::unique_ptr<WidgetWithBellsAndWhistles>>::const_iterator
它 = my_map_.find(key);
std::array<int, 6> 数字 = {4, 8, 15, 16, 23, 42};
```

**好代码**

```C++
自动小部件 = std::make_unique<WidgetWithBellsAndWhistles>(arg1, arg2);
自动它 = my_map_.find(key);
std::array 数字 = {4, 8, 15, 16, 23, 42};
```

类型有时包含有用信息和样板文件的混合体，例如上面示例中的 `it` ：很明显，该类型是一个迭代器，并且在许多上下文中，容器类型甚至键类型都不相关，但类型这些值可能很有用。在这种情况下，通常可以使用传达相关信息的显式类型来定义局部变量：

**好代码**

```C++
if (auto it = my_map_.find(key); it!= my_map_.end()) {
WidgetWithBellsAndWhistles& widget = *it->第二;
// 使用 `widget` 做一些事情
}
```

如果类型是模板实例，并且参数是样板文件，但模板本身提供信息，则可以使用类模板参数推导来抑制样板文件。然而，这实际上提供了有意义的好处的情况非常罕见。请注意，类模板参数推导也受_单独的样式规则_的约束。

如果更简单的选项可以工作，请不要使用 `decltype(auto)` ，因为它是一个相当晦涩的功能，因此在代码清晰度方面的成本很高。

### 返回类型推导

仅当函数体只有很少数量的 return 语句且其他代码很少时才使用返回类型推导（对于函数和 lambda），因为否则读者可能无法一眼看出返回类型是。此外，仅当函数或 lambda 的范围非常窄时才使用它，因为具有推导返回类型的函数不定义抽象边界：实现就是接口。特别是，头文件中的公共函数几乎不应该推导返回类型。

### 参数类型推导

应谨慎使用 lambda 的 `auto` 参数类型，因为实际类型由调用 lambda 的代码确定，而不是由 lambda 的定义确定。因此，显式类型几乎总是更清晰，除非 lambda 显式调用的位置非常接近其定义位置（以便读者可以轻松地看到两者），或者 lambda 被传递到一个众所周知的接口，以至于很明显什么参数它最终将被调用（例如上面的`std::sort`示例）。

### Lambda 初始化捕获

初始化捕获由_更具体的样式规则_覆盖，该规则在很大程度上取代了类型推导的一般规则。

### 结构化绑定

与其他形式的类型推导不同，结构化绑定实际上可以通过为较大对象的元素提供有意义的名称来为读者提供附加信息。这意味着结构化绑定声明可以比显式类型提供净可读性改进，即使在 `auto` 不能的情况下也是如此。当对象是一对或元组时（如上面的 `插入` 示例），结构化绑定特别有用，因为它们一开始就没有有意义的字段名称，但请注意，通常[不应该使用对或元组](#Structs_vs._Tuples) 除非像 `insert` 这样预先存在的 API 强制您这样做。

如果绑定的对象是一个结构体，有时提供更适合您的使用的名称可能会有所帮助，但请记住，这也可能意味着您的读者比字段名称更难识别这些名称。我们建议使用注释来指示基础字段的名称，如果它与绑定的名称不匹配，请使用与函数参数注释相同的语法：

```C++
自动 [/*field_name1=*/bound_name1, /*field_name2=*/bound_name2] = ...
```

与函数参数注释一样，这可以使工具检测到字段的顺序是否错误。

## 类模板参数推导

仅对已明确选择支持它的模板使用类模板参数推导。

[类模板参数推导](https://en.cppreference.com/w/cpp/language/class_template_argument_deduction)（通常缩写为 `CTAD` ）当使用命名模板的类型声明变量并且模板参数时发生未提供列表（甚至没有空尖括号）：

**中性代码**

```C++
std::array a = {1, 2, 3}; // `a` 是一个 std::array<int, 3>
```

编译器使用模板的 `推导指南` 从初始值设定项推导参数，该 `推导指南` 可以是显式的，也可以是隐式的。

显式推导指南看起来像带有尾随返回类型的函数声明，只不过没有前导 `auto` ，并且函数名称是模板的名称。例如，上面的例子依赖于`std::array`的推导指南：

**中性代码**

```C++
命名空间 std {
模板 <T 类，... U 类>
数组(T, U...) -> std::array<T, 1 + sizeof...(U)>;
}
```

主模板（与模板专门化相对）中的构造函数也隐式定义推导指南。

当您声明依赖于 CTAD 的变量时，编译器会使用构造函数重载解析规则选择推导指南，并且该指南的返回类型将成为变量的类型。

CTAD 有时可以允许您从代码中省略样板文件。

从构造函数生成的隐式推导指南可能具有不良行为，或者完全不正确。对于 C++17 中引入 CTAD 之前编写的构造函数来说，这尤其成问题，因为这些构造函数的作者无法了解（更不用说修复）其构造函数会给 CTAD 造成的任何问题。此外，添加显式推导指南来解决这些问题可能会破坏依赖隐式推导指南的任何现有代码。

CTAD 还存在许多与 `auto` 相同的缺点，因为它们都是从变量的初始值设定项推导变量的全部或部分类型的机制。 CTAD 确实为读者提供了比 `auto` 更多的信息，但它也没有给读者一个明显的提示：信息已被省略。

不要将 CTAD 与给定模板一起使用，除非模板的维护者已选择通过提供至少一个显式推导指南来支持 CTAD 的使用（ `std` 命名空间中的所有模板也被假定已选择加入）。如果有的话，应该通过编译器警告来强制执行。

CTAD 的使用还必须遵循_类型推导_的一般规则。

## 指定初始化器

仅以符合 C++20 的形式使用指定的初始值设定项。

[指定初始化器](https://en.cppreference.com/w/cpp/language/aggregate_initialization#Designated_initializers) 是一种允许通过显式命名聚合字段来初始化聚合（ `普通旧结构` ）的语法：

**中性代码**

```C++
结构点{
浮动 x = 0.0;
浮点y = 0.0;
浮动 z = 0.0;
};

点 p = {
.x = 1.0,
.y = 2.0,
// z 将是 0.0
};
```

显式列出的字段将按照指定进行初始化，其他字段将按照传统聚合初始化表达式（如 `Point{1.0, 2.0}` ）中的相同方式进行初始化。

指定的初始值设定项可以提供方便且高度可读的聚合表达式，特别是对于字段排序不如上面的 `Point` 示例那么简单的结构。

虽然指定初始值设定项长期以来一直是 C 标准的一部分，并作为扩展受到 C++ 编译器的支持，但直到最近它们才纳入 C++ 标准，并作为 C++20 的一部分添加。

C++ 标准中的规则比 C 和编译器扩展中的规则更严格，要求指定的初始值设定项的出现顺序与结构定义中字段的出现顺序相同。因此，在上面的示例中，根据 C++20，初始化 `x` 然后初始化 `z` 是合法的，但初始化 `y` 然后初始化 `x` 则不合法。

仅以与 C++20 标准兼容的形式使用指定的初始值设定项：初始值设定项的顺序与结构定义中出现的相应字段的顺序相同。

## Lambda 表达式

在适当的地方使用 lambda 表达式。当 lambda 将逃逸当前作用域时，首选显式捕获。

Lambda 表达式是创建匿名函数对象的一种简洁方式。当将函数作为参数传递时，它们通常很有用。例如：

```C++
std::sort(v.begin(), v.end(), [](int x, int y) {
返回权重（x）<权重（y）；
});
```

它们还允许从封闭范围中显式地按名称捕获变量，或隐式地使用默认捕获。显式捕获要求将每个变量作为值或引用捕获列出：

```C++
整数权重=3；
整数总和=0；
// 通过值捕获 `weight` ，通过引用捕获 `sum` 。
std::for_each(v.begin(), v.end(), [weight, &sum](int x) {
总和+=重量*x；
});
```

默认捕获隐式捕获 lambda 主体中引用的任何变量，包括 `this` （如果使用了任何成员）：

```C++
const std::vector<int> Lookup_table = ...;
std::vector<int> 索引 = ...;
// 通过引用捕获 `lookup_table`，按值对 `indices` 进行排序
// `lookup_table` 中的关联元素。
std::sort(indices.begin(),indexs.end(),[&](int a, int b) {
返回lookup_table[a] <lookup_table[b]；
});
```

变量捕获还可以有一个显式初始化程序，它可用于按值捕获仅移动变量，或用于普通引用或值捕获无法处理的其他情况：

```C++
std::unique_ptr<Foo> foo = ...;
[foo = std::move(foo)] () {
...
}
```

此类捕获（通常称为 `init captures` 或 `generalized lambda captures` ）实际上不需要从封闭范围中 `捕获` 任何内容，甚至不需要具有封闭范围中的名称；此语法是定义 lambda 对象成员的完全通用方法：

**中性代码**

```C++
[foo = std::vector<int>({1, 2, 3})] () {
...
}
```

使用与 `auto` 相同的规则推导带有初始值设定项的捕获类型。

- Lambda 比定义要传递给 STL 算法的函数对象的其他方法要简洁得多，这可以提高可读性。
- 适当使用默认捕获可以消除冗余并突出显示默认情况下的重要异常。
- Lambdas、`std::function` 和 `std::bind` 可以组合使用作为通用回调机制；它们使编写将绑定函数作为参数的函数变得容易。

- lambda 中的变量捕获可能是悬空指针错误的根源，特别是当 lambda 逃逸当前作用域时。
- 默认按值捕获可能会产生误导，因为它们不能防止悬空指针错误。按值捕获指针不会导致深层复制，因此它通常具有与按引用捕获相同的生命周期问题。当按值捕获 `this` 时，这尤其令人困惑，因为 `this` 的使用通常是隐式的。
- 捕获实际上声明了新变量（无论捕获是否具有初始值设定项），但它们看起来与 C++ 中的任何其他变量声明语法完全不同。特别是，没有地方容纳变量的类型，甚至没有 `auto` 占位符（尽管 init 捕获可以间接指示它，例如通过强制转换）。这使得甚至很难将它们识别为声明。
- Init 捕获本质上依赖于_类型推导_，并且具有许多与 `auto` 相同的缺点，还有一个额外的问题，即语法甚至没有提示读者正在进行推导。
- lambda 的使用可能会失控；太长的嵌套匿名函数会使代码更难理解。

- 在适当的情况下使用 lambda 表达式，格式设置如下所述。
- 如果 lambda 可能逃逸当前范围，则首选显式捕获。例如，代替：

**错误代码**

```C++
{
福福；
...
执行器->调度([&] { Frobnicate(foo); })
...
}
// 坏的！事实上 lambda 使用了对 `foo` 的引用并且
// 可能 `this` （如果 `Frobnicate` 是成员函数）可能不是
// 粗略检查即可发现。如果 lambda 是在之后调用的
// 函数返回，那会很糟糕，因为两个 `foo`
// 并且封闭的对象可能已被销毁。
```

更喜欢写：

```C++
{
福福；
...
执行器->Schedule([&foo] { Frobnicate(foo); })
...
}
// 更好 - 如果 `Frobnicate` 是成员，编译将会失败
// 函数，更清楚的是 `foo` 被危险地捕获
// 参考。
```

- 仅当 lambda 的生命周期明显短于任何潜在捕获时，才使用默认的引用捕获 (`[&]`)。
- 仅使用默认的按值捕获 (`[=]`) 作为为短 lambda 绑定一些变量的方法，其中捕获的变量集一目了然，并且不会导致隐式捕获 `this` 。 （这意味着出现在非静态类成员函数中并在其主体中引用非静态类成员的 lambda 必须显式捕获 `this` 或通过 `[&]` 捕获。） 最好不要编写长或复杂的 lambda默认按值捕获。
- 仅使用捕获来实际捕获封闭范围中的变量。不要将捕获与初始值设定项一起使用来引入新名称，或大幅更改现有名称的含义。相反，以传统方式声明一个新变量，然后捕获它，或者避免使用 lambda 简写并显式定义一个函数对象。
- 有关指定参数和返回类型的指导，请参阅_类型推导_部分。

## 模板元编程

避免复杂的模板编程。

模板元编程是指利用 C++ 模板实例化机制是图灵完备这一事实的一系列技术，可用于在类型域中执行任意编译时计算。

模板元编程允许极其灵活的接口，类型安全且高性能。如果没有它，像 [GoogleTest](https://github.com/google/googletest)、`std::tuple`、`std::function` 和 Boost.Spirit 这样的工具是不可能的。

除了语言专家之外，模板元编程中使用的技术通常对任何人来说都是晦涩难懂的。以复杂方式使用模板的代码通常不可读，并且难以调试或维护。

模板元编程通常会导致极其糟糕的编译时错误消息：即使接口很简单，当用户做错事情时，复杂的实现细节也会变得可见。

模板元编程使重构工具的工作变得更加困难，从而干扰大规模重构。首先，模板代码在多个上下文中扩展，并且很难验证转换在所有上下文中是否有意义。其次，一些重构工具使用的 AST 只表示模板扩展后的代码结构。自动恢复到需要重写的原始源结构可能很困难。

模板元编程有时可以提供比没有它时更干净、更易于使用的界面，但它也常常会让人变得过于聪明。它最好用于少量的低级组件，其中额外的维护负担分散在大量的用途中。

在使用模板元编程或其他复杂的模板技术之前请三思；考虑一下在你切换到另一个项目后，你的团队的普通成员是否能够很好地理解你的代码来维护它，或者非 C++ 程序员或随意浏览代码库的人是否能够理解错误消息或者跟踪他们想要调用的函数的流程。如果您使用递归模板实例化或类型列表或元函数或表达式模板，或者依赖 SFINAE 或 `sizeof` 技巧来检测函数重载解析，那么您很可能走得太远了。

如果您使用模板元编程，您应该付出相当大的努力来最小化和隔离复杂性。您应该尽可能将元编程隐藏为实现细节，以便面向用户的标头可读，并且您应该确保对棘手的代码进行了很好的注释。您应该仔细记录代码的使用方式，并且应该说明 `生成的` 代码是什么样子的。当用户犯错时，请特别注意编译器发出的错误消息。错误消息是用户界面的一部分，您的代码应该根据需要进行调整，以便从用户的角度来看错误消息是可以理解和可操作的。

## 促进

仅使用 Boost 库集合中经批准的库。

[Boost 库集合](https://www.boost.org/) 是经过同行评审的免费开源 C++ 库的流行集合。

Boost 代码通常质量非常高，具有广泛的可移植性，并且填补了 C++ 标准库中的许多重要空白，例如类型特征和更好的绑定器。

一些 Boost 库鼓励可能妨碍可读性的编码实践，例如元编程和其他高级模板技术，以及过度 `函数式` 的编程风格。

为了让所有可能阅读和维护代码的贡献者保持高水平的可读性，我们只允许经过批准的 Boost 功能子集。目前，允许使用以下库：

- [呼叫特征](https://www.boost.org/libs/utility/call_traits.htm) 来自 `boost/call_traits.hpp`
- 来自`boost/compressed_pair.hpp`的[压缩对](https://www.boost.org/libs/utility/compressed_pair.htm)
- [Boost Graph Library (BGL)](https://www.boost.org/libs/graph/) 来自 `boost/graph`，序列化 (`adj_list_serialize.hpp`) 和并行/分布式算法和数据结构除外（`boost/graph/parallel/*` 和 `boost/graph/distributed/*`）。
- 来自 `boost/property_map` 的 [属性映射](https://www.boost.org/libs/property_map/)，并行/分布式属性映射 (`boost/property_map/parallel/*`) 除外。
- 来自`boost/iterator`的[迭代器](https://www.boost.org/libs/iterator/)
- [Polygon](https://www.boost.org/libs/polygon/) 中处理 Voronoi 图构造的部分，不依赖于 Polygon 的其余部分：`boost/polygon/voronoi_builder.hpp`， `boost/polygon/voronoi_diagram.hpp` 和 `boost/polygon/voronoi_geometry_type.hpp`
- [Bimap](https://www.boost.org/libs/bimap/) 来自 `boost/bimap`
- [统计分布和函数](https://www.boost.org/libs/math/doc/html/dist.html) 来自`boost/math/distributions`
- [特殊函数](https://www.boost.org/libs/math/doc/html/special.html) 来自 `boost/math/special_functions`
- [求根和最小化函数](https://www.boost.org/libs/math/doc/html/root_finding.html) 来自 `boost/math/tools`
- [多索引](https://www.boost.org/libs/multi_index/) 来自 `boost/multi_index`
- 来自`boost/heap`的[堆](https://www.boost.org/libs/heap/)
- 来自 [Container](https://www.boost.org/libs/container/) 的扁平容器： `boost/container/flat_map` 和 `boost/container/flat_set`
- 来自`boost/intrusive`的[侵入](https://www.boost.org/libs/intrusive/)。
- [`boost/sort` 库](https://www.boost.org/libs/sort/)。
- 来自`boost/preprocessor`的[预处理器](https://www.boost.org/libs/preprocessor/)。

我们正在积极考虑将其他 Boost 功能添加到列表中，因此将来可能会扩展该列表。

## 其他 C++ 功能

与 _Boost_ 一样，一些现代 C++ 扩展鼓励妨碍可读性的编码实践，例如通过删除可能对读者有帮助的检查冗余（例如类型名称），或鼓励模板元编程。其他扩展重复了现有机制中可用的功能，这可能会导致混乱和转换成本。

除了样式指南其余部分中描述的内容之外，不得使用以下 C++ 功能：

- 编译时有理数（`<ratio>`），因为担心它与更依赖模板的界面风格相关。
- `<cfenv>` 和 `<fenv.h>` 标头，因为许多编译器不可靠地支持这些功能。
- `<filesystem>` 标头没有足够的测试支持，并且存在固有的安全漏洞。

## 非标准扩展

除非另有说明，否则不得使用 C++ 的非标准扩展。

编译器支持不属于标准 C++ 的各种扩展。此类扩展包括 GCC 的 `__attribute__` 、内部函数（例如 `__builtin_prefetch` 或 SIMD、 `#pragma` 、内联汇编、 `__COUNTER__` 、 `__PRETTY_FUNCTION__` ）、复合语句表达式（例如， `foo = ({ int x; Bar( &x); x })`、可变长度数组和 `alloca()`，以及 `[Elvis Operator](https://en.wikipedia.org/wiki/Elvis_operator)` `a?:b`。

- 非标准扩展可能提供标准 C++ 中不存在的有用功能。
- 对编译器的重要性能指导只能使用扩展来指定。

- 非标准扩展不适用于所有编译器。使用非标准扩展会降低代码的可移植性。
- 即使所有目标编译器都支持它们，但扩展通常没有明确指定，并且编译器之间可能存在细微的行为差异。
- 非标准扩展添加到读者必须了解的语言功能才能理解代码。
- 非标准扩展需要额外的工作才能跨架构移植。

不要使用非标准扩展。您可以使用通过非标准扩展实现的可移植性包装器，只要这些包装器是由指定的项目范围可移植性标头提供的。

## 别名

公共别名是为了 API 用户的利益，应明确记录。

有多种方法可以创建作为其他实体的别名的名称：

```C++
typedef Foo 酒吧；
使用 Bar = Foo;
使用 other_namespace::Foo;
```

在新代码中， `using` 优于 `typedef` ，因为它提供了与 C++ 其余部分更一致的语法，并且可以与模板一起使用。

与其他声明一样，头文件中声明的别名是该头文件的公共 API 的一部分，除非它们位于函数定义中、类的私有部分中或显式标记的内部命名空间中。这些区域或 `.cc` 文件中的别名是实现细节（因为客户端代码无法引用它们），并且不受此规则的限制。

- 别名可以通过简化长或复杂的名称来提高可读性。
- 别名可以通过在一个地方命名 API 中重复使用的类型来减少重复，这可能会让以后更容易更改类型。

- 当放置在客户端代码可以引用它们的标头中时，别名会增加该标头 API 中的实体数量，从而增加其复杂性。
- 客户可以轻松依赖公共别名的意外详细信息，从而使更改变得困难。
- 创建一个仅用于实现的公共别名可能很诱人，而不考虑它对 API 或可维护性的影响。
- 别名可能会造成名称冲突的风险
- 别名会给熟悉的结构赋予不熟悉的名称，从而降低可读性
- 类型别名可能会产生不明确的 API 契约：不清楚是否保证别名与其别名的类型相同、是否具有相同的 API，或者是否只能以指定的狭窄方式使用

不要仅仅为了节省实现中的输入而在公共 API 中添加别名；仅当您打算供客户使用时才这样做。

定义公共别名时，记录新名称的意图，包括是否保证它始终与其当前别名的类型相同，或者是否打算更有限的兼容性。这让用户知道他们是否可以将类型视为可替换，或者是否必须遵循更具体的规则，并且可以帮助实现保留一定程度的自由度来更改别名。

不要将命名空间别名放入公共 API 中。 （另请参阅_命名空间_）。

例如，这些别名记录了它们在客户端代码中的使用方式：

```C++
命名空间 mynamespace {
// 用于存储现场测量值。 DataPoint 可能会从 Bar* 更改为某种内部类型。
// 客户端代码应将其视为不透明指针。
使用 DataPoint = ::foo::Bar*;

// 一组测量值。只是为了用户方便而起的别名。
使用 TimeSeries = std::unordered_set<DataPoint, std::hash<DataPoint>, DataPointComparator>;
} // 命名空间 mynamespace
```

这些别名不记录预期用途，其中一半不适合客户端使用：

**错误代码**

```C++
命名空间 mynamespace {
// 不好：这些都没有说明应该如何使用它们。
使用 DataPoint = ::foo::Bar*;
使用::std::unordered_set； // 不好：只是为了本地方便
使用::std::哈希； // 不好：只是为了本地方便
typedef unordered_set<DataPoint, hash<DataPoint>, DataPointComparator> TimeSeries;
} // 命名空间 mynamespace
```

然而，本地便利别名在函数定义、类的 `私有` 部分、显式标记的内部命名空间以及 `.cc` 文件中很好用：

```C++
// 在 .cc 文件中
使用 ::foo::Bar;
```

## Switch 语句

如果不以枚举值为条件，则 switch 语句应始终具有 `default` 情况（在枚举值的情况下，如果未处理任何值，编译器将警告您）。如果默认情况永远不应该执行，请将其视为错误。例如：

```C++
开关（变量）{
情况0：{
...
休息;
}
情况1： {
...
休息;
}
默认： {
LOG(FATAL) << "switch 语句中的值无效：" << var;
}
}
```

从一个案例标签到另一个案例标签的跌落必须使用 `[[fallthrough]];` 属性进行注释。 `[[fallthrough]];` 应放置在发生跳转到下一个 case 标签的执行点。一个常见的例外是连续的 case 标签没有中间代码，在这种情况下不需要注释。

```C++
开关（x）{
case 41: // 这里不需要注释。
案例43：
如果（不要挑剔）{
// 使用它代替注释中的注释或与注释一起使用。
[[失败]]；
} 别的 {
关闭但没有雪茄（）；
休息;
}
案例42：
DoSomethingSpecial();
[[失败]]；
默认：
DoSomethingGeneric();
休息;
}
```

# 包容性语言

在所有代码中，包括命名和注释，请使用包容性语言并避免其他程序员可能认为不尊重或冒犯的术语（例如 `主` 和 `从` 、 `黑名单` 和 `白名单` 或 `红线` ），即使这些术语表面上也具有中性含义。同样，请使用中性语言，除非您指的是特定的人（并使用他们的代词）。例如，对未指定性别的人使用 `they` / `them` / `their` （[即使是单数](https://apastyle.apa.org/style-grammar-guidelines/grammar/singular-they)） ， `it` / `its` 用于软件、计算机和其他非人的事物。

# 命名

最重要的一致性规则是管理命名的规则。名称的样式立即告诉我们命名实体是什么类型：类型、变量、函数、常量、宏等，而不需要我们搜索该实体的声明。我们大脑中的模式匹配引擎很大程度上依赖于这些命名规则。

命名规则相当随意，但我们认为在这方面一致性比个人偏好更重要，所以无论你认为它们是否合理，规则就是规则。

## 一般命名规则

使用即使对于不同团队的人员来说也清晰的名称来优化可读性。

使用描述对象的目的或意图的名称。不要担心节省水平空间，因为让新读者立即理解您的代码更为重要。尽量减少项目外人员可能不知道的缩写词的使用（尤其是首字母缩略词和首字母缩写词）。不要通过删除单词中的字母来缩写。根据经验，如果维基百科中列出了缩写，则可能没问题。一般来说，描述性应该与名称的可见范围成正比。例如， `n` 在 5 行函数中可能是一个很好的名称，但在类的范围内，它可能太模糊了。

```C++
类我的类{
民众：
int CountFooErrors(const std::vector<Foo>& foos) {
整数 n = 0; // 考虑到有限的范围和上下文，含义清晰
for (const auto& foo : foos) {
...
++n；
}
返回n；
}
无效DoSomethingImportant（）{
std::string fqdn = ...; // 著名的完全限定域名缩写
}
私人的：
const int kMaxAllowedConnections = ...; // 上下文中含义清晰
};
```

**错误代码**

```C++
类我的类{
民众：
int CountFooErrors(const std::vector<Foo>& foos) {
int foo_errors 总数 = 0; // 由于范围和上下文有限，过于冗长
for (int foo_index = 0; foo_index < foos.size(); ++foo_index) { // 使用惯用的 `i`
...
++foo_errors 总数；
}
返回 foo_errors 总数；
}
无效DoSomethingImportant（）{
int cstmr_id = ...; // 删除内部字母
}
私人的：
常量 int kNum = ...; // 广泛范围内含义不明确
};
```

请注意，某些众所周知的缩写是可以的，例如迭代变量的 `i` 和模板参数的 `T` 。

出于以下命名规则的目的， `单词` 是您用英语编写的没有内部空格的任何内容。这包括缩写词，例如首字母缩略词和缩写词。对于以混合大小写书写的名称（有时也称为 `[camel case](https://en.wikipedia.org/wiki/Camel_case)` 或 `[Pascal case](https://en.wiktionary.org/ wiki/Pascal_case)")，其中每个单词的第一个字母都大写，更喜欢将缩写作为单个单词大写，例如`StartRpc()`而不是`StartRPC()`。

模板参数应遵循其类别的命名风格：类型模板参数应遵循_类型名称_规则，非类型模板参数应遵循_变量名称_规则。

## 文件名

文件名应全部小写，并且可以包含下划线 (`_`) 或破折号 (`-`)。遵循您的项目使用的约定。如果没有一致的本地模式可遵循，则首选 `_` 。

可接受的文件名示例：

- `my_useful_class.cc`
- `我的有用类.cc`
- `myusefulclass.cc`
- `myusefulclass_test.cc // _unittest 和 _regtest 已弃用。`

C++ 文件应以 `.cc` 结尾，头文件应以 `.h` 结尾。依赖于在特定点以文本方式包含的文件应以 `.inc` 结尾（另请参阅有关[自包含标头](#Self_contained_Headers)的部分）。

不要使用`/usr/include`中已经存在的文件名，例如`db.h`。

一般来说，让你的文件名非常具体。例如，使用 `http_server_logs.h` 而不是 `logs.h` 。一个非常常见的情况是有一对名为 `foo_bar.h` 和 `foo_bar.cc` 的文件，定义一个名为 `FooBar` 的类。

## 类型名称

类型名称以大写字母开头，每个新单词都大写，不带下划线：`MyExcitingClass`、`MyExcitingEnum`。

所有类型的名称（类、结构、类型别名、枚举和类型模板参数）都具有相同的命名约定。类型名称应以大写字母开头，并且每个新单词都有大写字母。没有下划线。例如：

```C++
// 类和结构
类 UrlTable { ...
类 UrlTableTester { ...
结构 UrlTableProperties { ...

// 类型定义
typedef hash_map<UrlTableProperties *, std::string> PropertiesMap;

// 使用别名
使用 PropertiesMap = hash_map<UrlTableProperties *, std::string>;

// 枚举
枚举类 UrlTableError { ...
```

## 变量名称

变量（包括函数参数）和数据成员的名称为 `snake_case` （全部小写，单词之间有下划线）。类（但不是结构）的数据成员另外还有尾随下划线。例如：`a_local_variable`、`a_struct_data_member`、`a_class_data_member_`。

### 常用变量名

例如：

```C++
std::string 表名； // 好的——snake_case。
```

**错误代码**

```C++
std::字符串表名； // 不好 - 大小写混合。
```

### 类数据成员

类的数据成员（静态和非静态）的命名方式与普通非成员变量类似，但末尾带有下划线。

```C++
类表信息{
...
私人的：
std::string 表名_； // OK - 末尾有下划线。
静态池<TableInfo>* pool_; // 好的。
};
```

### 结构数据成员

结构的数据成员（静态和非静态）的命名方式与普通非成员变量类似。它们没有类中数据成员所具有的尾部下划线。

```C++
结构 UrlTableProperties {
std::字符串名称；
int num_entries；
静态池<UrlTableProperties>*池；
};
```

请参阅[结构与类](#Structs_vs._Classes) 了解何时使用结构与类的讨论。

## 常量名称

声明为 `constexpr` 或 `const` 的变量，其值在程序运行期间是固定的，以前导 `k` 命名，后跟混合大小写。在极少数无法使用大写字母进行分隔的情况下，可以使用下划线作为分隔符。例如：

```C++
常量 int kDaysInAWeek = 7;
常量 int kAndroid8_0_0 = 24; // 安卓8.0.0
```

所有具有静态存储持续时间的变量（即静态变量和全局变量，有关详细信息，请参阅[存储持续时间](http://en.cppreference.com/w/cpp/language/storage_duration#Storage_duration)）都应该以这种方式命名。对于其他存储类的变量，例如自动变量，此约定是可选的；否则，应用通常的变量命名规则。例如：

```C++
void ComputeFoo(absl::string_view 后缀) {
// 其中任何一个都是可以接受的。
const absl::string_view kPrefix = "前缀";
const absl::string_view prefix = "前缀";
...
}
```

**错误代码**

```C++
void ComputeFoo(absl::string_view 后缀) {
// 不好 - ComputeFoo 的不同调用给出 kCombined 不同的值。
const std::string kCombined = absl::StrCat(kPrefix, suffix);
...
}
```

## 函数名称

常规函数具有混合大小写；访问器和修改器可以像变量一样命名。

通常，函数应以大写字母开头，并且每个新单词都有一个大写字母。

```C++
添加表条目()
删除网址()
打开文件或模具()
```

（相同的命名规则适用于作为 API 的一部分公开的类和命名空间范围常量，这些常量旨在看起来像函数，因为它们是对象而不是函数这一事实是一个不重要的实现细节。）

访问器和修改器（获取和设置函数）可以像变量一样命名。这些通常对应于实际的成员变量，但这不是必需的。例如， `int count()` 和 `void set_count(int count)` 。

## 命名空间名称

命名空间名称全部小写，单词之间用下划线分隔。顶级命名空间名称基于项目名称。避免嵌套命名空间和众所周知的顶级命名空间之间的冲突。

顶级命名空间的名称通常应该是其代码包含在该命名空间中的项目或团队的名称。该命名空间中的代码通常应位于基本名称与命名空间名称匹配的目录中（或其子目录中）。

请记住，_针对缩写名称的规则_与变量名称一样适用于名称空间。命名空间内的代码很少需要提及命名空间名称，因此通常不需要特别缩写。

避免与众所周知的顶级命名空间匹配的嵌套命名空间。由于名称查找规则，名称空间名称之间的冲突可能会导致意外的构建中断。特别是，不要创建任何嵌套的 `std` 命名空间。优先选择唯一的项目标识符（`websearch::index`、`websearch::index_util`）而不是容易发生冲突的名称，例如`websearch::util`。还要避免嵌套过深的命名空间（[TotW #130](https://abseil.io/tips/130)）。

对于 `内部` 命名空间，请注意其他代码添加到同一 `内部` 命名空间会导致冲突（团队内的内部助手往往是相关的，并可能导致冲突）。在这种情况下，使用文件名创建唯一的内部名称会很有帮助（ `websearch::index::frobber_internal` 用于 `frobber.h` ）。

## 枚举器名称

枚举数（对于有作用域和无作用域枚举）应该命名为_constants_，而不是_macros_。也就是说，使用 `kEnumName` 而不是 `ENUM_NAME` 。

```C++
枚举类 UrlTableError {
kOk = 0,
k内存不足，
k格式错误的输入，
};
```

**错误代码**

```C++
枚举类 AlternateUrlTableError {
好=0，
内存输出 = 1,
MALFORMED_INPUT = 2,
};
```

2009 年 1 月之前，枚举值的命名风格仍为 _macros_。这导致了枚举值和宏之间的名称冲突问题。因此，倾向于使用常量样式命名的更改已经到位。新代码应使用常量样式命名。

## 宏名称

您不会真的要_定义宏_，是吗？如果你这样做，它们就像这样： `MY_MACRO_THAT_SCARES_SMALL_CHILDREN_AND_ADULTS_ALIKE` 。

请参阅_宏说明_；一般来说，不应使用宏。但是，如果绝对需要它们，则应使用全部大写和下划线以及特定于项目的前缀来命名它们。

```C++
#define MYPROJECT_ROUND(x) ...
```

## 命名规则的例外情况

如果您要命名的内容类似于现有的 C 或 C++ 实体，那么您可以遵循现有的命名约定方案。

- `bigopen()`

函数名称，遵循`open()`的形式

- `uint`

`typedef`

- `大波斯`

`struct` 或 `class`，遵循 `pos` 的形式

- `sparse_hash_map`

类似STL的实体；遵循 STL 命名约定

- `LONGLONG_MAX`

一个常量，如 `INT_MAX`

# 评论

注释对于保持我们的代码可读性绝对至关重要。以下规则描述了您应该评论什么以及在哪里评论。但请记住：虽然注释非常重要，但最好的代码是自我记录的。为类型和变量提供合理的名称比使用晦涩的名称要好得多，然后您必须通过注释进行解释。

在撰写评论时，请为您的受众撰写：下一个需要理解您的代码的贡献者。慷慨一点——下一个可能就是你！

## 评论风格

使用 `//` 或 `/* */` 语法，只要保持一致即可。

您可以使用 `//` 或 `/* */` 语法；然而， `//` 更为常见。与你的评论方式和你在哪里使用的风格保持一致。

## 文件评论

使用许可证样板启动每个文件。

如果源文件（例如 `.h` 文件）声明了多个面向用户的抽象（通用函数、相关类等），请包含描述这些抽象集合的注释。包含足够的细节，以便未来的作者知道哪些不适合那里。但是，有关各个抽象的详细文档属于这些抽象，而不是文件级别。

例如，如果您为 `frobber.h` 编写文件注释，则不需要在 `frobber.cc` 或 `frobber_test.cc` 中包含文件注释。另一方面，如果您在 `registered_objects.cc` 中编写没有关联头文件的类集合，则必须在 `registered_objects.cc` 中包含文件注释。

### 法律声明和作者行

每个文件都应包含许可证样板。为项目使用的许可证选择适当的样板（例如，Apache 2.0、BSD、LGPL、GPL）。

如果您对包含作者行的文件进行重大更改，请考虑删除作者行。新文件通常不应包含版权声明或作者行。

## 课堂评论

每个不明显的类或结构声明都应该有一个附带的注释，描述它的用途以及如何使用它。

```C++
// 迭代 GargantuanTable 的内容。
// 例子：
// std::unique_ptr<GargantuanTableIterator> iter = table->NewIterator();
// for (iter->Seek("foo"); !iter->done(); iter->Next()) {
// 进程(iter->key(), iter->value());
// }
类 GargantuanTableIterator {
...
};
```

类注释应该为读者提供足够的信息，以了解如何以及何时使用该类，以及正确使用该类所需的任何其他注意事项。记录该类所做的同步假设（如果有）。如果类的实例可以由多个线程访问，请特别注意记录有关多线程使用的规则和不变量。

类注释通常是放置小示例代码片段的好地方，演示该类的简单且集中的用法。

当充分分离时（例如， `.h` 和 `.cc` 文件），描述类使用的注释应与其接口定义一起使用；关于类操作和实现的注释应该伴随类方法的实现。

## 函数注释

声明注释描述了函数的使用（当它不明显时）；函数定义处的注释描述操作。

### 函数声明

几乎每个函数声明前面都应该有注释，描述该函数的作用以及如何使用它。仅当函数简单且明显时（例如，用于类的明显属性的简单访问器），才可以省略这些注释。在 `.cc` 文件中声明的私有方法和函数也不例外。函数注释应以 `此函数` 作为隐含主语，并以动词短语开头；例如， `打开文件` ，而不是 `打开文件` 。一般来说，这些注释不描述函数如何执行其任务。相反，应该将其留给函数定义中的注释。

函数声明注释中要提及的内容类型：

- 输入和输出是什么。如果函数参数名称在 `反引号` 中提供，那么代码索引工具可能能够更好地呈现文档。
- 对于类成员函数：对象是否在方法调用持续时间之外记住引用或指针参数。这对于构造函数的指针/引用参数来说很常见。
- 对于每个指针参数，是否允许为空以及如果为空会发生什么。
- 对于每个输出或输入/输出参数，该参数所处的任何状态会发生什么情况。（例如，状态是附加的还是覆盖的？）。
- 函数的使用方式是否对性能有任何影响。

这是一个例子：

```C++
// 返回该表的迭代器，位于第一个条目
// 词法上大于或等于 `start_word`。如果没有
// 这样的条目，返回一个空指针。客户端不得使用
// 底层 GargantuanTable 被销毁后的迭代器。
//
// 该方法相当于：
// std::unique_ptr<Iterator> iter = table->NewIterator();
// iter->Seek(start_word);
// 返回迭代器；
std::unique_ptr<Iterator> GetIterator(absl::string_view start_word) const;
```

但是，不要过于冗长或陈述完全显而易见的内容。

在记录函数重写时，请重点关注重写本身的细节，而不是重复被重写函数的注释。在许多这样的情况下，覆盖不需要额外的文档，因此不需要任何评论。

在注释构造函数和析构函数时，请记住阅读代码的人知道构造函数和析构函数的用途，因此仅说 `销毁此对象` 之类的注释是没有用的。记录构造函数对其参数执行的操作（例如，如果它们获取指针的所有权），以及析构函数执行的清理操作。如果这是微不足道的，请跳过评论。析构函数没有标题注释是很常见的。

### 函数定义

如果函数如何完成其工作有任何棘手的地方，函数定义应该有一个解释性注释。例如，在定义注释中，您可以描述您使用的任何编码技巧，概述您所经历的步骤，或者解释为什么您选择以这种方式实现该功能，而不是使用可行的替代方案。例如，您可能会提到为什么它必须为函数的前半部分获取锁，但为什么后半部分不需要它。

请注意，您不应该只是在 `.h` 文件或任何地方重复函数声明中给出的注释。简要概括一下该函数的作用是可以的，但注释的重点应该是它是如何实现的。

## 变量注释

一般来说，变量的实际名称应该具有足够的描述性，以便很好地了解变量的用途。在某些情况下，需要更多评论。

### 类数据成员

每个类数据成员（也称为实例变量或成员变量）的用途必须明确。如果有任何不变量（特殊值、成员之间的关系、生命周期要求）没有通过类型和名称明确表达，则必须对其进行注释。但是，如果类型和名称足够（`int num_events_;`），则不需要注释。

特别是，当哨兵值不明显时，添加注释来描述哨兵值的存在和含义，例如 nullptr 或 -1。例如：

```C++
私人的：
// 用于对表访问进行边界检查。 -1表示
// 我们还不知道表有多少条目。
int num_total_entries_;
```

### 全局变量

所有全局变量都应该有一个注释，描述它们是什么、它们的用途以及（如果不清楚）为什么它们需要是全局的。例如：

```C++
// 我们在此回归测试中运行的测试用例总数。
const int kNumTestCases = 6;
```

## 实施意见

在你的实现中，你应该在代码中棘手的、不明显的、有趣的或重要的部分添加注释。

### 解释性评论

棘手或复杂的代码块前面应该有注释。

### 函数参数注释

当函数参数的含义不明显时，请考虑以下补救措施之一：

- 如果参数是文字常量，并且在多个函数调用中使用相同的常量，默认它们是相同的，则应该使用命名常量来明确该约束，并保证它成立。
- 考虑更改函数签名以将 `bool` 参数替换为 `enum` 参数。这将使论证值具有自我描述性。
- 对于具有多个配置选项的函数，请考虑定义一个类或结构来保存所有选项，并传递其实例。这种方法有几个优点。选项在调用站点通过名称引用，这阐明了它们的含义。它还减少了函数参数数量，从而使函数调用更易于读写。作为一个额外的好处，您在添加另一个选项时不必更改调用站点。
- 用命名变量替换大型或复杂的嵌套表达式。
- 作为最后的手段，使用注释来澄清调用站点的参数含义。

考虑以下示例：**错误代码**

```C++
// 这些参数是什么？
const DecimalNumber 产品 =CalculateProduct(values, 7, false, nullptr);
```

相对：

```C++
ProductOptions 选项；
选项.set_ precision_decimals(7);
options.set_use_cache(ProductOptions::kDontUseCache);
const DecimalNumber 产品 =
CalculateProduct(值，选项，/*completion_callback=*/nullptr);
```

### 不该做的事

不要陈述显而易见的事情。特别是，不要从字面上描述代码的作用，除非该行为对于很好理解 C++ 的读者来说并不明显。相反，提供更高级别的注释来描述代码为何执行其操作，或者使代码自我描述。

比较一下：**错误代码**

```C++
// 查找向量中的元素。 <-- 坏：显而易见！
if (std::find(v.begin(), v.end(), element) != v.end()) {
过程（元素）；
}
```

对此：

```C++
// 处理 `元素` ，除非它已经被处理过。
if (std::find(v.begin(), v.end(), element) != v.end()) {
过程（元素）；
}
```

自描述代码不需要注释。上面例子的注释是显而易见的：

```C++
if (!IsAlreadyProcessed(element)) {
过程（元素）；
}
```

## 标点符号、拼写和语法

注意标点符号、拼写和语法；阅读写得好的评论比阅读写得不好的评论更容易。

注释应该像叙述性文本一样可读，并使用正确的大写和标点符号。在许多情况下，完整的句子比句子片段更具可读性。较短的注释，例如一行代码末尾的注释，有时可能不太正式，但您应该与您的风格保持一致。

尽管代码审阅者指出您在应该使用分号时使用了逗号可能会令人沮丧，但源代码保持高度的清晰度和可读性非常重要。正确的标点符号、拼写和语法有助于实现这一目标。

## TODO 评论

对临时代码、短期解决方案或足够好但不完美的代码使用 `TODO` 注释。

 `TODO` 应包含全部大写的字符串 `TODO` ，后跟错误 ID、名称、电子邮件地址或人员或问题的其他标识符，以及有关 `TODO` 所引用问题的最佳上下文。

```C++
// TODO：bug 12345678 - 在 2047q4 兼容性窗口到期后删除此错误。
// TODO：example.com/my-design-doc - 下次触摸时手动修复此代码。
// TODO（bug 12345678）：在 Foo 服务关闭后更新此列表。
// TODO(John): 此处使用 `\*` 作为连接运算符。
```

如果您的 `TODO` 的形式是 `在将来的某个日期做某事` ，请确保您包含一个非常具体的日期（ `2005 年 11 月之前修复` ）或一个非常具体的事件（ `当所有客户端都可以处理时删除此代码` ） XML 响应。` ）。

# 格式化

编码风格和格式非常随意，但如果每个人都使用相同的风格，项目就会更容易遵循。个人可能并不同意格式规则的每个方面，并且某些规则可能需要一些时间来适应，但重要的是所有项目贡献者都遵循样式规则，以便他们都可以轻松阅读和理解每个人的代码。

为了帮助您正确设置代码格式，我们创建了一个 [emacs 设置文件](https://raw.githubusercontent.com/google/styleguide/gh-pages/google-c-style.el)。

## 线长

代码中的每行文本长度最多应为 80 个字符。

我们认识到这条规则是有争议的，但很多现有代码已经遵守它，我们认为一致性很重要。

那些支持这一规则的人认为，强迫他们调整窗户大小是粗鲁的，而且没有必要再做任何事情了。有些人习惯于并排使用多个代码窗口，因此在任何情况下都没有空间来扩大窗口。人们在设置工作环境时会假设特定的最大窗户宽度，而 80 列一直是传统标准。为什么要改变它？

变革的支持者认为，更宽的行可以使代码更具可读性。 80 列的限制是对 20 世纪 60 年代大型机的墨守成规。现代设备具有宽屏幕，可以轻松显示更长的队伍。

最多 80 个字符。

一行可能超过 80 个字符，如果

- 在不损害可读性、易于剪切和粘贴或自动链接的情况下无法分割的注释行 - 例如，如果一行包含示例命令或长度超过 80 个字符的文字 URL。
- 无法轻易包装为 80 列的字符串文字。这可能是因为它包含 URI 或其他语义关键部分，或者因为文字包含嵌入式语言，或多行文字，其换行符像帮助消息一样重要。在这些情况下，分解文字会降低可读性、可搜索性、单击链接的能力等。除了测试代码之外，此类文字应出现在文件顶部附近的命名空间范围内。如果像 Clang-Format 这样的工具无法识别不可分割的内容，请[禁用该工具](https://clang.llvm.org/docs/ClangFormatStyleOptions.html#disabling-formatting-on-a-piece-of-code ）根据需要围绕内容。

（我们必须在这些文字的可用性/可搜索性和它们周围的代码的可读性之间取得平衡。）

- 包含语句。
- _头球后卫_
- 使用声明

## 非 ASCII 字符

非 ASCII 字符应该很少出现，并且必须使用 UTF-8 格式。

您不应该在源代码中对面向用户的文本进行硬编码，即使是英语，因此应该很少使用非 ASCII 字符。但是，在某些情况下，在代码中包含此类单词是合适的。例如，如果您的代码解析来自外部源的数据文件，则可能适合将这些数据文件中使用的非 ASCII 字符串硬编码为分隔符。更常见的是，单元测试代码（不需要本地化）可能包含非 ASCII 字符串。在这种情况下，您应该使用 UTF-8，因为这是大多数能够处理 ASCII 以外的工具所理解的编码。

十六进制编码也可以，并且在增强可读性的地方受到鼓励 - 例如，`"\xEF\xBB\xBF"`，或者更简单的是，`"\uFEFF"`，是 Unicode 零宽度不间断空格字符，如果以纯 UTF-8 形式包含在源中，该字符将不可见。

如果可能，请避免使用 `u8` 前缀。从 C++20 开始，它的语义与 C++17 中的语义显着不同，生成 `char8_t` 数组而不是 `char` 数组。

您不应使用 `char16_t` 和 `char32_t` 字符类型，因为它们适用于非 UTF-8 文本。出于类似的原因，您也不应该使用 `wchar_t` （除非您正在编写与 Windows API 交互的代码，该 API 广泛使用 `wchar_t` ）。

## 空格与制表符

仅使用空格，并且一次缩进 2 个空格。

我们使用空格进行缩进。不要在代码中使用制表符。您应该将编辑器设置为在按 Tab 键时发出空格。

## 函数声明和定义

返回类型与函数名称在同一行，参数在同一行（如果合适）。包装那些不适合放在一行上的参数列表，就像您将参数包装在_函数调用_中一样。

函数如下所示：

```C++
ReturnType ClassName::FunctionName(类型 par_name1, 类型 par_name2) {
做一点事（）;
...
}
```

如果您的文本太多而无法在一行中容纳：

```C++
ReturnType ClassName::ReallyLongFunctionName(类型 par_name1, 类型 par_name2,
输入 par_name3) {
做一点事（）;
...
}
```

或者如果您甚至无法容纳第一个参数：

```C++
返回类型 LongClassName::ReallyReallyReallyLongFunctionName(
type par_name1, // 4 个空格缩进
输入 par_name2,
输入 par_name3) {
做一点事（）; // 2个空格缩进
...
}
```

需要注意的几点：

- 选择好的参数名称。
- 仅当函数定义中未使用参数时，才可以省略参数名称。
- 如果无法将返回类型和函数名称放在一行中，请在它们之间换行。
- 如果在函数声明或定义的返回类型之后中断，请勿缩进。
- 左括号始终与函数名称在同一行。
- 函数名称和左括号之间绝不能有空格。
- 括号和参数之间决不能有空格。
- 左大括号始终位于函数声明的最后一行的末尾，而不是下一行的开头。
- 右花括号单独位于最后一行，或者与左花括号位于同一行。
- 右括号和左花括号之间应该有一个空格。
- 如果可能的话，所有参数应对齐。
- 默认缩进为 2 个空格。
- 包裹参数有 4 个空格缩进。

从上下文中显而易见的未使用的参数可以被省略：

```C++
类 Foo {
民众：
Foo(const Foo&) = 删除;
Foo& 运算符=(const Foo&) = 删除;
};
```

可能不明显的未使用参数应注释掉函数定义中的变量名称：

```C++
类形状{
民众：
虚拟无效旋转（双弧度）= 0；
};

类圆：公共形状{
民众：
void 旋转（双弧度）覆盖；
};

void Circle::Rotate(double /*弧度*/) {}
```

**错误代码**

```C++
// 不好 - 如果有人想稍后实现，则不清楚该做什么
// 变量的意思。
无效圆::旋转（双）{}
```

属性和扩展为属性的宏出现在函数声明或定义的最开头，返回类型之前：

```C++
ABSL_ATTRIBUTE_NOINLINE 无效 ExpenseFunction();
[[nodiscard]] bool IsOk();
```

## Lambda 表达式

像任何其他函数一样格式化参数和主体，并像其他逗号分隔列表一样捕获列表。

对于按引用捕获，请勿在与号 (`&`) 和变量名称之间留有空格。

```C++
整数x=0；
auto x_plus_n = [&x](int n) -> int { return x + n; }
```

短 lambda 可以内联编写为函数参数。

```C++
absl::flat_hash_set<int> to_remove = {7, 8, 9};
std::vector<int> 数字 = {3, 9, 1, 8, 4, 7, 1};
digits.erase(std::remove_if(digits.begin(),digits.end(),[&to_remove](int i) {
返回到_remove.contains(i);
}),
数字.end());
```

## 浮点文字

浮点文字应该始终有一个小数点，两边都有数字，即使它们使用指数表示法。如果所有浮点文字都采用这种熟悉的形式，则可读性会得到提高，因为这有助于确保它们不会被误认为整数文字，并且指数表示法的 `E` / `e` 不会被误认为十六进制数字。可以使用整数文字来初始化浮点变量（假设变量类型可以精确表示该整数），但请注意，指数表示法中的数字永远不是整数文字。

**错误代码**

```C++
浮动 f = 1.f;
长双 ld = -.5L；
双 d = 1248e6；
```

**好代码**

```C++
浮点数 f = 1.0f；
浮动 f2 = 1; //也可以
长双ld = -0.5L；
双 d = 1248.0e6；
```

## 函数调用

将调用全部写在一行上，将参数括在括号中，或者在新行上开始参数，缩进 4 个空格，并在 4 个空格缩进处继续。在没有其他考虑的情况下，请使用最少的行数，包括在适当的情况下在每行上放置多个参数。

函数调用具有以下格式：

```C++
布尔结果 = DoSomething(参数 1, 参数 2, 参数 3);
```

如果参数不能全部放在一行上，则应将它们分成多行，每个后续行与第一个参数对齐。不要在左括号之后或右括号之前添加空格：

```C++
布尔结果 = DoSomething(averyveryveryverylongargument1,
参数2、参数3)；
```

参数可以选择全部放置在后续行中，并缩进四个空格：

```C++
如果 （...） {
...
...
如果 （...） {
布尔结果 = DoSomething(
argument1, argument2, // 4 个空格缩进
参数 3、参数 4)；
...
}
```

将多个参数放在一行上以减少调用函数所需的行数，除非存在特定的可读性问题。有些人发现，在每一行上严格使用一个参数进行格式化更具可读性，并且简化了参数的编辑。然而，我们优先考虑的是读者编辑参数的便利性，并且大多数可读性问题可以通过以下技术更好地解决。

如果由于构成某些参数的表达式的复杂性或令人困惑的性质，在一行中包含多个参数会降低可读性，请尝试创建以描述性名称捕获这些参数的变量：

```C++
int my_heuristic = 分数[x] * y + 基数[x]；
布尔结果 = DoSomething(my_heuristic, x, y, z);
```

或者将令人困惑的论点单独放在一行并附上解释性注释：

```C++
bool result = DoSomething(scores[x] * y + bases[x], // 启发式得分。
x、y、z）；
```

如果仍然存在一个参数在其自己的行中明显更具可读性的情况，则将其放在自己的行中。该决定应该针对更具可读性的论点，而不是一般政策。

有时参数形成的结构对于可读性很重要。在这些情况下，请随意根据该结构格式化参数：

```C++
// 将小部件变换为 3x3 矩阵。
my_widget.Transform(x1, x2, x3,
y1、y2、y3、
z1、z2、z3)；
```

## 大括号初始化列表格式

格式化大括号初始值设定项列表的格式与格式化函数调用的位置完全相同。

如果大括号列表后面有一个名称（例如，类型或变量名称），则格式就像 `{}` 是使用该名称的函数调用的括号一样。如果没有名称，则假定名称长度为零。

```C++
// 单行上花括号初始化列表的示例。
返回{foo，酒吧}；
函数调用({foo, bar});
std::pair<int, int> p{foo, bar};

// 当你必须换行时。
一些函数（
{ `假设 {` } 之前有一个零长度名称，
一些_其他_函数_参数）；
SomeType 变量{
一些、其他、价值观、
{ `假设 {` } 之前有一个零长度名称，
一些其他类型{
 `非常长的字符串需要周围的中断。` ,
一些、其他、值},
SomeOtherType{"稍短的字符串",
一些、其他、值}}；
SomeType 变量{
 `这太长了，无法在一行中全部容纳` }；
MyType m = { // 在这里，您也可以在 { 之前中断。
超长变量名1,
超长变量名2,
{短，内部，列表}，
{内部包装列表，
内部包装列表2}}；
```

## 循环和分支语句

在较高层次上，循环或分支语句由以下**组件**组成：

- 一个或多个**语句关键字**（例如 `if` 、 `else` 、 `switch` 、 `while` 、 `do` 或 `for` ）。
- 一个**条件或迭代说明符**，位于括号内。
- 一个或多个**受控语句**，或受控语句块。

对于这些陈述：

- 语句的各个组成部分应该用单个空格（而不是换行符）分隔。
- 在条件或迭代说明符内，在每个分号和下一个标记之间放置一个空格（或换行符），除非该标记是右括号或另一个分号。
- 在条件或迭代说明符内，请勿在左括号之后或右括号之前放置空格。
- 将任何受控语句放入块内（即使用花括号）。
- 在受控块内，在紧接左大括号之后放置一个换行符，并在紧邻右大括号之前放置一个换行符。

```C++
if (condition) { // 好 - 括号内没有空格，大括号前有空格。
DoOneThing(); // 好 - 两个空格缩进。
做另一件事（）；
} else if (int a = f(); a != 3) { // 好 - 右大括号位于新行，否则位于同一行。
做第三件事(a);
} 别的 {
没做什么（）;
}

// 好 - 相同的规则适用于循环。
while（条件）{
重复AThing();
}

// 好 - 相同的规则适用于循环。
做 {
重复AThing();
while（条件）；

// 好 - 相同的规则适用于循环。
for (int i = 0; i < 10; ++i) {
重复AThing();
}
```

**错误代码**

```C++
if(condition) {} // 不好 - `if` 后面缺少空格。
else if (条件) {} // 不好 - 括号和条件之间有空格。
else if (condition){} // 不好 - `{` 之前缺少空格。
else if(condition){} // 不好 - 缺少多个空格。

for (int a = f();a == 10) {} // 不好 - 分号后缺少空格。

// 不好 - `if ... else` 语句没有到处都有大括号。
如果（条件）
富；
别的 {
酒吧;
}

// 不好 - `if` 语句太长而无法省略大括号。
如果（条件）
// 评论
做一点事（）;

// 不好 - `if` 语句太长而无法省略大括号。
if (条件1 &&
条件2)
做一点事（）;
```

由于历史原因，我们允许上述规则有一个例外：受控语句的大括号或大括号内的换行符可以被省略，如果结果是整个语句出现在单行上（在这种情况下，右括号和受控语句之间的空格）或两行（在这种情况下，右括号后面有一个换行符，并且没有大括号）。

**中性代码**

```C++
// 好的 - 适合一行。
if (x == kFoo) { return new Foo(); } }

// 好的 - 在这种情况下大括号是可选的。
if (x == kFoo) 返回 new Foo();

// OK - 条件适合一条线，主体适合另一条线。
如果 (x == kBar)
酒吧（参数1，参数2，参数3）；
```

此例外不适用于多关键字语句，例如 `if ... else` 或 `do ... while` 。

**错误代码**

```C++
// 不好 - `if ... else` 语句缺少大括号。
如果 (x) DoThis();
否则 DoThat();

// 不好 - `do ... while` 语句缺少大括号。
执行 DoThis();
同时（x）；
```

仅当语句简短时才使用此样式，并考虑到具有复杂条件的循环和分支语句或受控语句使用花括号可能会更具可读性。有些项目始终需要花括号。

`switch` 语句中的 `case` 块可以有花括号，也可以没有，具体取决于您的偏好。如果您确实包含花括号，则应如下所示放置它们。

```C++
开关（变量）{
case 0: { // 2 个空格缩进
Foo(); // 4个空格缩进
休息;
}
默认： {
酒吧（）;
}
}
```

空循环体应该使用一对空大括号或不带大括号的 `继续` ，而不是单个分号。

```C++
while (condition) {} // 好 - `{}` 表示没有逻辑。
while（条件）{
// 注释也可以
}
while（条件）继续； // 好 - `继续` 表示没有逻辑。
```

**错误代码**

```C++
同时（条件）； // 不好 - 看起来像是 `do-while` 循环的一部分。
```

## 指针和引用表达式

句点或箭头周围没有空格。指针运算符没有尾随空格。

以下是格式正确的指针和引用表达式的示例：

```C++
x = *p；
p = &x;
x = ry;
x = r->y；
```

注意：

- 访问成员时，句点或箭头周围没有空格。
- 指针运算符在 `*` 或 `&` 之后没有空格。

当引用指针或引用（变量声明或定义、参数、返回类型、模板参数等）时，可以在星号/与号之前或之后放置空格。在尾随空格样式中，在某些情况下（模板参数等）会省略空格。

```C++
// 这些都很好，前面有空格。
字符*c；
const std::string &str;
int *GetPointer();
std::向量<字符*>

// 这些都很好，后面有空格（或省略）。
字符* c；
const std::string& str;
int* GetPointer();
std::vector<char*> // 注意 '*' 和 '>' 之间没有空格
```

您应该在单个文件中一致地执行此操作。修改现有文件时，请使用该文件中的样式。

允许（如果不寻常）在同一个声明中声明多个变量，但如果其中任何一个变量具有指针或引用修饰，则不允许这样做。此类声明很容易被误读。

```C++
// 如果对可读性有帮助的话就很好。
整数x，y；
```

**错误代码**

```C++
整数x，*y； // 不允许 - 多重声明中不能有 & 或 *
int* x, *y; // 不允许 - 多重声明中不能有 & 或 *；间距不一致
字符*c； // 不好 - * 两边有空格
const std::string & str; // 不好 - & 两边有空格
```

## 布尔表达式

当您的布尔表达式比_标准行长度_长时，请在拆分行时保持一致。

在此示例中，逻辑 AND 运算符始终位于行的末尾：

```C++
if (this_one_thing > this_other_thing &&
a_third_thing == a_fourth_thing &&
Yet_another && last_one) {
...
}
```

请注意，当代码在此示例中换行时，两个 `&&` 逻辑 AND 运算符都位于行尾。这在 Google 代码中更常见，尽管也允许将所有运算符包装在行的开头。请随意明智地插入额外的括号，因为如果使用得当，它们对提高可读性非常有帮助，但要小心过度使用。另请注意，您应该始终使用标点符号运算符，例如 `&&` 和 `~` ，而不是单词运算符，例如 `and` 和 `compl` 。

## 返回值

不要不必要地将 `return` 表达式用括号括起来。

仅当在 `x = expr;` 中使用括号时，才在 `return expr;` 中使用括号。

```C++
返回结果； // 简单情况下没有括号。
// 括号可以使复杂的表达式更具可读性。
返回（some_long_condition &&
另一个_条件）；
```

**错误代码**

```C++
返回（值）； // 你不会写 var = (value);
返回（结果）； // return 不是函数！
```

## 变量和数组初始化

您可以在 `=` 、 `()` 和 `{}` 之间进行选择；以下都是正确的：

```C++
整数x = 3;
整数x(3)；
整数x{3}；
std::string name = "某个名称";
std::string name("某个名称");
std::string name{"Some Name"};
```

在带有 `std::initializer_list` 构造函数的类型上使用大括号初始化列表 `{...}` 时要小心。只要可能，非空 _braced-init-list_ 更喜欢 `std::initializer_list` 构造函数。请注意，空大括号 `{}` 是特殊的，如果可用，它将调用默认构造函数。要强制使用非 std::initializer_list 构造函数，请使用括号而不是大括号。

```C++
std::vector<int> v(100, 1); // 包含 100 个项目的向量：全为 1。
std::vector<int> v{100, 1}; // 包含 2 个项目的向量：100 和 1。
```

此外，大括号形式可以防止整数类型变窄。这可以防止某些类型的编程错误。

```C++
int pi(3.14); // 好的——pi == 3。
int pi{3.14}； // 编译错误：缩小转换。
```

## 预处理器指令

启动预处理器指令的哈希标记应始终位于行的开头。

即使预处理器指令位于缩进代码体内，这些指令也应从行首开始。

```C++
// 好 - 指令位于行首
如果（不平衡的分数）{
#if DISASTER_PENDING // 正确 -- 从行首开始
删除一切（）；
# if NOTIFY // 可以，但不是必需的 -- # 后有空格
通知客户端();
# 万一
#万一
回到正常（）；
}
```

**错误代码**

```C++
// 错误 - 缩进指令
如果（不平衡的分数）{
#if DISASTER_PENDING // 错误！  `#if` 应该位于行首
删除一切（）；
#endif // 错误！不要缩进 `#endif`
回到正常（）；
}
```

## 班级格式

 `公共` 、 `受保护` 和 `私有` 顺序中的部分，每个部分缩进一个空格。

类定义的基本格式（缺少注释，请参阅_类注释_以讨论需要哪些注释）：

```C++
类 MyClass : 公共 OtherClass {
public: // 注意 1 个空格缩进！
我的课（）; // 常规 2 个空格缩进。
显式 MyClass(int var);
~MyClass() {}

无效一些函数（）；
void SomeFunctionThatDoesNothing() {
}

void set_some_var(int var) { some_var_ = var; }
int some_var() const { 返回 some_var_; }

私人的：
bool SomeInternalFunction();

int some_var_;
int some_other_var_；
};
```

注意事项：

- 任何基类名称应与子类名称在同一行，但须遵守 80 列的限制。
- `public:`、`protected:` 和 `private:` 关键字应缩进一个空格。
- 除第一个实例外，这些关键字前面应有一个空行。在小班中，此规则是可选的。
- 不要在这些关键字后留空行。
-  `public` 部分应该放在第一位，然后是 `protected` 部分，最后是 `private` 部分。
- 有关每个部分中声明排序的规则，请参阅_声明顺序_。

## 构造函数初始化列表

构造函数初始值设定项列表可以全部在一行中，也可以在后续行中缩进四个空格。

可接受的初始值设定项列表格式为：

```C++
// 当所有内容都适合一行时：
MyClass::MyClass(int var) : some_var_(var) {
做一点事（）;
}

// 如果签名和初始值设定项列表不全部在一行上，
// 必须在冒号前换行并缩进 4 个空格：
MyClass::MyClass(int var)
: some_var_(var), some_other_var_(var + 1) {
做一点事（）;
}

// 当列表跨越多行时，将每个成员放在自己的行上
// 并对齐它们：
MyClass::MyClass(int var)
: some_var_(var), // 4 个空格缩进
some_other_var_(var + 1) { // 排队
做一点事（）;
}

// 与任何其他代码块一样，闭合卷曲可以位于同一块上
// 将线条作为开放式卷曲（如果合适）。
MyClass::MyClass(int var)
: some_var_(var) {}
```

## 命名空间格式化

命名空间的内容不缩进。

_命名空间_不添加额外的缩进级别。例如，使用：

```C++
命名空间{

void foo() { // 正确。命名空间内没有额外的缩进。
...
}

} // 命名空间
```

不要在命名空间内缩进：

**错误代码**

```C++
命名空间{

// 错误的！不应该缩进的时候缩进。
无效 foo() {
...
}

} // 命名空间
```

## 水平空白

水平空白的使用取决于位置。切勿在行尾放置尾随空格。

### 一般的

```C++
整数 i = 0; // 行尾注释前有两个空格。

void f(bool b) { // 左大括号前面应始终有一个空格。
...
整数 i = 0; // 分号前面通常没有空格。
// braced-init-list 大括号内的空格是可选的。如果你使用它们，
// 把它们放在两边！
int x[] = { 0 };
int x[] = {0};

// 继承和初始化列表中冒号周围的空格。
类 Foo : 公共酒吧 {
民众：
// 对于内联函数实现，在大括号之间放置空格
// 以及实现本身。
Foo(int b) : Bar(), baz_(b) {} // 空大括号内没有空格。
无效重置() { baz_ = 0; } // 用空格分隔大括号和实现。
...
```

添加尾随空格可能会给编辑同一文件的其他人带来额外的工作，当它们合并时，删除现有的尾随空格也会造成额外的工作。所以：不要引入尾随空格。如果您已经更改了该行，请将其删除，或者在单独的清理操作中执行此操作（最好是在没有其他人处理该文件时）。

### 循环和条件

```C++
if (b) { // 条件和循环中关键字后的空格。
} else { // else 周围有空格。
}
while (test) {} // 括号内通常没有空格。
开关（一）{
for (int i = 0; i < 5; ++i) {
// 循环和条件可能在括号内有空格，但是这个
// 很少见。始终如一。
开关（我）{
如果（测试）{
for ( int i = 0; i < 5; ++i ) {
// For 循环在分号后始终有一个空格。他们可能有一个空间
// 在分号之前，但这种情况很少见。
为（；我<5；++i）{
...

// 基于范围的 for 循环在冒号前后始终有一个空格。
for (auto x : 计数) {
...
}
开关（一）{
case 1: // switch case 中冒号前没有空格。
...
情况2：中断； // 如果冒号后有代码，则在冒号后使用空格。
```

### 运算符

```C++
// 赋值运算符周围总是有空格。
x = 0;

// 其他二元运算符周围通常有空格，但它是
// 可以删除因子周围的空格。括号里不能有
// 内部填充。
v = w * x + y / z;
v = w*x + y/z；
v = w * (x + z);

// 一元运算符及其参数之间没有空格分隔。
x = -5;
++x；
如果 (x && !y)
...
```

### 模板和转换

```C++
// 尖括号（< 和 >）之前没有空格
// < 或 >( 之间的强制转换
std::vector<std::string> x;
y = static_cast<char*>(x);

// 类型和指针之间可以有空格，但要保持一致。
std::vector<char *> x;
```

## 垂直空白

尽量减少垂直空白的使用。

这与其说是一条规则，不如说是一条原则：不必要时不要使用空行。特别是，函数之间不要放置超过一两个空行，不要以空行开始函数，不要以空行结束函数，并且要少用空行。代码块中的空行就像散文中的段落分隔符：在视觉上分隔两个想法。

基本原则是：一个屏幕上显示的代码越多，就越容易遵循和理解程序的控制流程。有目的地使用空格来在该流程中提供分隔。

当空行可能有用时，一些经验法则可以提供帮助：

- 函数开头或结尾的空行无助于可读性。
- if-else 块链内的空行可能有助于提高可读性。
- 注释行之前的空行通常有助于提高可读性——新注释的引入表明新想法的开始，并且空行清楚地表明注释与后面的内容而不是前面的内容相关。
- 命名空间或命名空间块的声明内紧邻的空行可以通过在视觉上将承载内容与（主要是非语义的）组织包装器分开来提高可读性。特别是当命名空间内的第一个声明前面有注释时，这成为前一个规则的特例，帮助注释 `附加` 到后续声明。

# 规则的例外情况

上述编码约定是强制性的。然而，就像所有好的规则一样，这些规则有时也有例外，我们在这里讨论。

## 现有的不合格代码

在处理不符合本风格指南的代码时，您可能会偏离规则。

如果您发现自己修改的代码不是按照本指南提供的规范编写的，那么您可能必须偏离这些规则，以便与该代码中的本地约定保持一致。如果您对如何执行此操作有疑问，请询问原作者或当前负责代码的人员。请记住，_一致性_也包括本地一致性。

## Windows 代码

Windows 程序员开发了自己的一套编码约定，主要源自 Windows 标头和其他 Microsoft 代码中的约定。我们希望让任何人都能轻松理解您的代码，因此我们为在任何平台上编写 C++ 的每个人提供了一套指南。

如果您习惯了流行的 Windows 风格，那么值得重申一下您可能会忘记的一些准则：

- 不要使用匈牙利表示法（例如，命名整数 `iNum` ）。使用 Google 命名约定，包括源文件的 `.cc` 扩展名。
- Windows 为原始类型定义了许多自己的同义词，例如 `DWORD` 、 `HANDLE` 等。在调用 Windows API 函数时使用这些类型是完全可以接受和鼓励的。即便如此，请尽可能接近底层的 C++ 类型。例如，使用 `const TCHAR *` 而不是 `LPCTSTR` 。
- 使用 Microsoft Visual C++ 进行编译时，将编译器设置为警告级别 3 或更高，并将所有警告视为错误。
- 不要使用`#pragma Once`；相反，使用标准的 Google include 防护。包含防护中的路径应该相对于项目树的顶部。
- 事实上，不要使用任何非标准扩展，例如 `#pragma` 和 `__declspec` ，除非绝对必须。允许使用 `__declspec(dllimport)` 和 `__declspec(dllexport)` ；但是，您必须通过 `DLLIMPORT` 和 `DLLEXPORT` 等宏来使用它们，以便有人共享代码时可以轻松禁用扩展。

然而，在 Windows 上我们偶尔需要打破一些规则：

- 通常我们_强烈不鼓励使用多重实现继承_；但是，在使用 COM 和某些 ATL/WTL 类时需要它。您可以使用多个实现继承来实现 COM 或 ATL/WTL 类和接口。
- 尽管您不应在自己的代码中使用异常，但它们在 ATL 和某些 STL（包括 Visual C++ 附带的异常）中广泛使用。使用 ATL 时，您应该定义 `_ATL_NO_EXCEPTIONS` 来禁用异常。您应该研究是否也可以在 STL 中禁用异常，但如果不能，则可以在编译器中打开异常。 （请注意，这只是为了编译 STL。您仍然不应该自己编写异常处理代码。）
- 使用预编译头的通常方法是在每个源文件的顶部包含一个头文件，通常名称为 `StdAfx.h` 或 `precompile.h` 。为了使您的代码更容易与其他项目共享，请避免显式包含此文件（ `precompile.cc` 中除外），并使用 `/FI` 编译器选项自动包含该文件。
- 资源标头通常名为 `resource.h` 并且仅包含宏，不需要符合这些样式指南。
